(ns portkey.aws.lex-models (:require [portkey.aws]))

(clojure.spec.alpha/def :portkey.aws.lex-models.bot-metadata/name (clojure.spec.alpha/and :portkey.aws.lex-models/bot-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.bot-metadata/description (clojure.spec.alpha/and :portkey.aws.lex-models/description))
(clojure.spec.alpha/def :portkey.aws.lex-models.bot-metadata/status (clojure.spec.alpha/and :portkey.aws.lex-models/status))
(clojure.spec.alpha/def :portkey.aws.lex-models.bot-metadata/last-updated-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.bot-metadata/created-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.bot-metadata/version (clojure.spec.alpha/and :portkey.aws.lex-models/version))
(clojure.spec.alpha/def :portkey.aws.lex-models/bot-metadata (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.bot-metadata/name :portkey.aws.lex-models.bot-metadata/description :portkey.aws.lex-models.bot-metadata/status :portkey.aws.lex-models.bot-metadata/lastUpdatedDate :portkey.aws.lex-models.bot-metadata/createdDate :portkey.aws.lex-models.bot-metadata/version]))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-bots-response/bots (clojure.spec.alpha/and :portkey.aws.lex-models/bot-metadata-list))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bots-response/next-token (clojure.spec.alpha/and :portkey.aws.lex-models/next-token))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-bots-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.get-bots-response/bots :portkey.aws.lex-models.get-bots-response/nextToken]))

(clojure.spec.alpha/def :portkey.aws.lex-models/slot-list (clojure.spec.alpha/coll-of :portkey.aws.lex-models/slot :max-count 100))

(clojure.spec.alpha/def :portkey.aws.lex-models.bot-alias-metadata/name (clojure.spec.alpha/and :portkey.aws.lex-models/alias-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.bot-alias-metadata/description (clojure.spec.alpha/and :portkey.aws.lex-models/description))
(clojure.spec.alpha/def :portkey.aws.lex-models.bot-alias-metadata/bot-version (clojure.spec.alpha/and :portkey.aws.lex-models/version))
(clojure.spec.alpha/def :portkey.aws.lex-models.bot-alias-metadata/bot-name (clojure.spec.alpha/and :portkey.aws.lex-models/bot-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.bot-alias-metadata/last-updated-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.bot-alias-metadata/created-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.bot-alias-metadata/checksum (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models/bot-alias-metadata (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.bot-alias-metadata/name :portkey.aws.lex-models.bot-alias-metadata/description :portkey.aws.lex-models.bot-alias-metadata/botVersion :portkey.aws.lex-models.bot-alias-metadata/botName :portkey.aws.lex-models.bot-alias-metadata/lastUpdatedDate :portkey.aws.lex-models.bot-alias-metadata/createdDate :portkey.aws.lex-models.bot-alias-metadata/checksum]))

(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-alias-request/name (clojure.spec.alpha/and :portkey.aws.lex-models/alias-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-alias-request/description (clojure.spec.alpha/and :portkey.aws.lex-models/description))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-alias-request/bot-version (clojure.spec.alpha/and :portkey.aws.lex-models/version))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-alias-request/bot-name (clojure.spec.alpha/and :portkey.aws.lex-models/bot-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-alias-request/checksum (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models/put-bot-alias-request (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.put-bot-alias-request/name :portkey.aws.lex-models.put-bot-alias-request/botVersion :portkey.aws.lex-models.put-bot-alias-request/botName] :opt-un [:portkey.aws.lex-models.put-bot-alias-request/description :portkey.aws.lex-models.put-bot-alias-request/checksum]))

(clojure.spec.alpha/def :portkey.aws.lex-models/locale-list (clojure.spec.alpha/coll-of :portkey.aws.lex-models/locale :max-count nil))

(clojure.spec.alpha/def :portkey.aws.lex-models.delete-slot-type-request/name (clojure.spec.alpha/and :portkey.aws.lex-models/slot-type-name))
(clojure.spec.alpha/def :portkey.aws.lex-models/delete-slot-type-request (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.delete-slot-type-request/name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lex-models/builtin-intent-metadata-list (clojure.spec.alpha/coll-of :portkey.aws.lex-models/builtin-intent-metadata :max-count nil))

(clojure.spec.alpha/def :portkey.aws.lex-models.resource-reference/name (clojure.spec.alpha/and :portkey.aws.lex-models/name))
(clojure.spec.alpha/def :portkey.aws.lex-models.resource-reference/version (clojure.spec.alpha/and :portkey.aws.lex-models/version))
(clojure.spec.alpha/def :portkey.aws.lex-models/resource-reference (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.resource-reference/name :portkey.aws.lex-models.resource-reference/version]))

(clojure.spec.alpha/def :portkey.aws.lex-models/lambdaarn (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__30837__auto__] (clojure.core/<= 20 (clojure.core/count s__30837__auto__))) (clojure.core/fn [s__30838__auto__] (clojure.core/< (clojure.core/count s__30838__auto__) 2048)) (clojure.core/fn [s__30839__auto__] (clojure.core/re-matches #"arn:aws:lambda:[a-z]+-[a-z]+-[0-9]:[0-9]{12}:function:[a-zA-Z0-9-_]+(/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})?(:[a-zA-Z0-9-_]+)?" s__30839__auto__))))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-aliases-response/bot-aliases (clojure.spec.alpha/and :portkey.aws.lex-models/bot-alias-metadata-list))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-aliases-response/next-token (clojure.spec.alpha/and :portkey.aws.lex-models/next-token))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-bot-aliases-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.get-bot-aliases-response/BotAliases :portkey.aws.lex-models.get-bot-aliases-response/nextToken]))

(clojure.spec.alpha/def :portkey.aws.lex-models.prompt/messages (clojure.spec.alpha/and :portkey.aws.lex-models/message-list))
(clojure.spec.alpha/def :portkey.aws.lex-models.prompt/max-attempts (clojure.spec.alpha/and :portkey.aws.lex-models/prompt-max-attempts))
(clojure.spec.alpha/def :portkey.aws.lex-models.prompt/response-card (clojure.spec.alpha/and :portkey.aws.lex-models/response-card))
(clojure.spec.alpha/def :portkey.aws.lex-models/prompt (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.prompt/messages :portkey.aws.lex-models.prompt/maxAttempts] :opt-un [:portkey.aws.lex-models.prompt/responseCard]))

(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-response/intents (clojure.spec.alpha/and :portkey.aws.lex-models/intent-list))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-response/created-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-response/idle-sessionttlin-seconds (clojure.spec.alpha/and :portkey.aws.lex-models/sessionttl))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-response/clarification-prompt (clojure.spec.alpha/and :portkey.aws.lex-models/prompt))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-response/name (clojure.spec.alpha/and :portkey.aws.lex-models/bot-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-response/locale (clojure.spec.alpha/and :portkey.aws.lex-models/locale))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-response/last-updated-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-response/status (clojure.spec.alpha/and :portkey.aws.lex-models/status))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-response/abort-statement (clojure.spec.alpha/and :portkey.aws.lex-models/statement))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-response/version (clojure.spec.alpha/and :portkey.aws.lex-models/version))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-response/failure-reason (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-response/child-directed (clojure.spec.alpha/and :portkey.aws.lex-models/boolean))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-response/checksum (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-response/voice-id (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-response/description (clojure.spec.alpha/and :portkey.aws.lex-models/description))
(clojure.spec.alpha/def :portkey.aws.lex-models/put-bot-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.put-bot-response/intents :portkey.aws.lex-models.put-bot-response/createdDate :portkey.aws.lex-models.put-bot-response/idleSessionTTLInSeconds :portkey.aws.lex-models.put-bot-response/clarificationPrompt :portkey.aws.lex-models.put-bot-response/name :portkey.aws.lex-models.put-bot-response/locale :portkey.aws.lex-models.put-bot-response/lastUpdatedDate :portkey.aws.lex-models.put-bot-response/status :portkey.aws.lex-models.put-bot-response/abortStatement :portkey.aws.lex-models.put-bot-response/version :portkey.aws.lex-models.put-bot-response/failureReason :portkey.aws.lex-models.put-bot-response/childDirected :portkey.aws.lex-models.put-bot-response/checksum :portkey.aws.lex-models.put-bot-response/voiceId :portkey.aws.lex-models.put-bot-response/description]))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-channel-association-response/name (clojure.spec.alpha/and :portkey.aws.lex-models/bot-channel-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-channel-association-response/description (clojure.spec.alpha/and :portkey.aws.lex-models/description))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-channel-association-response/bot-alias (clojure.spec.alpha/and :portkey.aws.lex-models/alias-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-channel-association-response/bot-name (clojure.spec.alpha/and :portkey.aws.lex-models/bot-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-channel-association-response/created-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-channel-association-response/type (clojure.spec.alpha/and :portkey.aws.lex-models/channel-type))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-channel-association-response/bot-configuration (clojure.spec.alpha/and :portkey.aws.lex-models/channel-configuration-map))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-bot-channel-association-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.get-bot-channel-association-response/name :portkey.aws.lex-models.get-bot-channel-association-response/description :portkey.aws.lex-models.get-bot-channel-association-response/botAlias :portkey.aws.lex-models.get-bot-channel-association-response/botName :portkey.aws.lex-models.get-bot-channel-association-response/createdDate :portkey.aws.lex-models.get-bot-channel-association-response/type :portkey.aws.lex-models.get-bot-channel-association-response/botConfiguration]))

(clojure.spec.alpha/def :portkey.aws.lex-models.bad-request-exception/message (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models/bad-request-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.bad-request-exception/message]))

(clojure.spec.alpha/def :portkey.aws.lex-models/channel-configuration-map (clojure.spec.alpha/map-of :portkey.aws.lex-models/string :portkey.aws.lex-models/string))

(clojure.spec.alpha/def :portkey.aws.lex-models.precondition-failed-exception/message (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models/precondition-failed-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.precondition-failed-exception/message]))

(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-alias-response/name (clojure.spec.alpha/and :portkey.aws.lex-models/alias-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-alias-response/description (clojure.spec.alpha/and :portkey.aws.lex-models/description))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-alias-response/bot-version (clojure.spec.alpha/and :portkey.aws.lex-models/version))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-alias-response/bot-name (clojure.spec.alpha/and :portkey.aws.lex-models/bot-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-alias-response/last-updated-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-alias-response/created-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-alias-response/checksum (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models/put-bot-alias-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.put-bot-alias-response/name :portkey.aws.lex-models.put-bot-alias-response/description :portkey.aws.lex-models.put-bot-alias-response/botVersion :portkey.aws.lex-models.put-bot-alias-response/botName :portkey.aws.lex-models.put-bot-alias-response/lastUpdatedDate :portkey.aws.lex-models.put-bot-alias-response/createdDate :portkey.aws.lex-models.put-bot-alias-response/checksum]))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-bots-request/next-token (clojure.spec.alpha/and :portkey.aws.lex-models/next-token))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bots-request/max-results (clojure.spec.alpha/and :portkey.aws.lex-models/max-results))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bots-request/name-contains (clojure.spec.alpha/and :portkey.aws.lex-models/bot-name))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-bots-request (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.get-bots-request/nextToken :portkey.aws.lex-models.get-bots-request/maxResults :portkey.aws.lex-models.get-bots-request/nameContains]))

(clojure.spec.alpha/def :portkey.aws.lex-models/locale (clojure.spec.alpha/conformer (clojure.core/let [m__30835__auto__ {"en-US" "en-US", :en-us "en-US"}] (clojure.core/fn [s__30836__auto__] (m__30835__auto__ s__30836__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.awsgen/dashed)))

(clojure.spec.alpha/def :portkey.aws.lex-models.utterance-data/utterance-string (clojure.spec.alpha/and :portkey.aws.lex-models/utterance-string))
(clojure.spec.alpha/def :portkey.aws.lex-models.utterance-data/count (clojure.spec.alpha/and :portkey.aws.lex-models/count))
(clojure.spec.alpha/def :portkey.aws.lex-models.utterance-data/distinct-users (clojure.spec.alpha/and :portkey.aws.lex-models/count))
(clojure.spec.alpha/def :portkey.aws.lex-models.utterance-data/first-uttered-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.utterance-data/last-uttered-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models/utterance-data (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.utterance-data/utteranceString :portkey.aws.lex-models.utterance-data/count :portkey.aws.lex-models.utterance-data/distinctUsers :portkey.aws.lex-models.utterance-data/firstUtteredDate :portkey.aws.lex-models.utterance-data/lastUtteredDate]))

(clojure.spec.alpha/def :portkey.aws.lex-models/alias-name-or-list-all (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__30837__auto__] (clojure.core/<= 1 (clojure.core/count s__30837__auto__))) (clojure.core/fn [s__30838__auto__] (clojure.core/< (clojure.core/count s__30838__auto__) 100)) (clojure.core/fn [s__30839__auto__] (clojure.core/re-matches #"^(-|^[a-zA-Z]+((_[a-zA-Z]+)*|([a-zA-Z]+_)*))$" s__30839__auto__))))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-channel-associations-request/bot-name (clojure.spec.alpha/and :portkey.aws.lex-models/bot-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-channel-associations-request/bot-alias (clojure.spec.alpha/and :portkey.aws.lex-models/alias-name-or-list-all))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-channel-associations-request/next-token (clojure.spec.alpha/and :portkey.aws.lex-models/next-token))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-channel-associations-request/max-results (clojure.spec.alpha/and :portkey.aws.lex-models/max-results))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-channel-associations-request/name-contains (clojure.spec.alpha/and :portkey.aws.lex-models/bot-channel-name))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-bot-channel-associations-request (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.get-bot-channel-associations-request/botName :portkey.aws.lex-models.get-bot-channel-associations-request/botAlias] :opt-un [:portkey.aws.lex-models.get-bot-channel-associations-request/nextToken :portkey.aws.lex-models.get-bot-channel-associations-request/maxResults :portkey.aws.lex-models.get-bot-channel-associations-request/nameContains]))

(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-request/intents (clojure.spec.alpha/and :portkey.aws.lex-models/intent-list))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-request/idle-sessionttlin-seconds (clojure.spec.alpha/and :portkey.aws.lex-models/sessionttl))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-request/clarification-prompt (clojure.spec.alpha/and :portkey.aws.lex-models/prompt))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-request/name (clojure.spec.alpha/and :portkey.aws.lex-models/bot-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-request/locale (clojure.spec.alpha/and :portkey.aws.lex-models/locale))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-request/process-behavior (clojure.spec.alpha/and :portkey.aws.lex-models/process-behavior))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-request/abort-statement (clojure.spec.alpha/and :portkey.aws.lex-models/statement))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-request/child-directed (clojure.spec.alpha/and :portkey.aws.lex-models/boolean))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-request/checksum (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-request/voice-id (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-bot-request/description (clojure.spec.alpha/and :portkey.aws.lex-models/description))
(clojure.spec.alpha/def :portkey.aws.lex-models/put-bot-request (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.put-bot-request/name :portkey.aws.lex-models.put-bot-request/locale :portkey.aws.lex-models.put-bot-request/childDirected] :opt-un [:portkey.aws.lex-models.put-bot-request/intents :portkey.aws.lex-models.put-bot-request/idleSessionTTLInSeconds :portkey.aws.lex-models.put-bot-request/clarificationPrompt :portkey.aws.lex-models.put-bot-request/processBehavior :portkey.aws.lex-models.put-bot-request/abortStatement :portkey.aws.lex-models.put-bot-request/checksum :portkey.aws.lex-models.put-bot-request/voiceId :portkey.aws.lex-models.put-bot-request/description]))

(clojure.spec.alpha/def :portkey.aws.lex-models/prompt-max-attempts (clojure.spec.alpha/and clojure.core/int? (fn* [p1__30878__30879__auto__] (clojure.core/<= 1 p1__30878__30879__auto__)) (fn* [p1__30880__30881__auto__] (clojure.core/<= p1__30880__30881__auto__ 5))))

(clojure.spec.alpha/def :portkey.aws.lex-models/builtin-intent-slot-list (clojure.spec.alpha/coll-of :portkey.aws.lex-models/builtin-intent-slot :max-count nil))

(clojure.spec.alpha/def :portkey.aws.lex-models.create-bot-version-request/name (clojure.spec.alpha/and :portkey.aws.lex-models/bot-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-bot-version-request/checksum (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models/create-bot-version-request (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.create-bot-version-request/name] :opt-un [:portkey.aws.lex-models.create-bot-version-request/checksum]))

(clojure.spec.alpha/def :portkey.aws.lex-models/numerical-version (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__30837__auto__] (clojure.core/<= 1 (clojure.core/count s__30837__auto__))) (clojure.core/fn [s__30838__auto__] (clojure.core/< (clojure.core/count s__30838__auto__) 64)) (clojure.core/fn [s__30839__auto__] (clojure.core/re-matches #"[0-9]+" s__30839__auto__))))

(clojure.spec.alpha/def :portkey.aws.lex-models.utterance-list/bot-version (clojure.spec.alpha/and :portkey.aws.lex-models/version))
(clojure.spec.alpha/def :portkey.aws.lex-models.utterance-list/utterances (clojure.spec.alpha/and :portkey.aws.lex-models/list-of-utterance))
(clojure.spec.alpha/def :portkey.aws.lex-models/utterance-list (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.utterance-list/botVersion :portkey.aws.lex-models.utterance-list/utterances]))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-utterances-view-response/bot-name (clojure.spec.alpha/and :portkey.aws.lex-models/bot-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-utterances-view-response/utterances (clojure.spec.alpha/and :portkey.aws.lex-models/lists-of-utterances))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-utterances-view-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.get-utterances-view-response/botName :portkey.aws.lex-models.get-utterances-view-response/utterances]))

(clojure.spec.alpha/def :portkey.aws.lex-models.create-slot-type-version-response/name (clojure.spec.alpha/and :portkey.aws.lex-models/slot-type-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-slot-type-version-response/description (clojure.spec.alpha/and :portkey.aws.lex-models/description))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-slot-type-version-response/enumeration-values (clojure.spec.alpha/and :portkey.aws.lex-models/enumeration-values))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-slot-type-version-response/last-updated-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-slot-type-version-response/created-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-slot-type-version-response/version (clojure.spec.alpha/and :portkey.aws.lex-models/version))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-slot-type-version-response/checksum (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models/create-slot-type-version-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.create-slot-type-version-response/name :portkey.aws.lex-models.create-slot-type-version-response/description :portkey.aws.lex-models.create-slot-type-version-response/enumerationValues :portkey.aws.lex-models.create-slot-type-version-response/lastUpdatedDate :portkey.aws.lex-models.create-slot-type-version-response/createdDate :portkey.aws.lex-models.create-slot-type-version-response/version :portkey.aws.lex-models.create-slot-type-version-response/checksum]))

(clojure.spec.alpha/def :portkey.aws.lex-models.delete-intent-version-request/name (clojure.spec.alpha/and :portkey.aws.lex-models/intent-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.delete-intent-version-request/version (clojure.spec.alpha/and :portkey.aws.lex-models/numerical-version))
(clojure.spec.alpha/def :portkey.aws.lex-models/delete-intent-version-request (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.delete-intent-version-request/name :portkey.aws.lex-models.delete-intent-version-request/version] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-builtin-slot-types-response/slot-types (clojure.spec.alpha/and :portkey.aws.lex-models/builtin-slot-type-metadata-list))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-builtin-slot-types-response/next-token (clojure.spec.alpha/and :portkey.aws.lex-models/next-token))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-builtin-slot-types-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.get-builtin-slot-types-response/slotTypes :portkey.aws.lex-models.get-builtin-slot-types-response/nextToken]))

(clojure.spec.alpha/def :portkey.aws.lex-models.statement/messages (clojure.spec.alpha/and :portkey.aws.lex-models/message-list))
(clojure.spec.alpha/def :portkey.aws.lex-models.statement/response-card (clojure.spec.alpha/and :portkey.aws.lex-models/response-card))
(clojure.spec.alpha/def :portkey.aws.lex-models/statement (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.statement/messages] :opt-un [:portkey.aws.lex-models.statement/responseCard]))

(clojure.spec.alpha/def :portkey.aws.lex-models/user-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__30837__auto__] (clojure.core/<= 2 (clojure.core/count s__30837__auto__))) (clojure.core/fn [s__30838__auto__] (clojure.core/< (clojure.core/count s__30838__auto__) 100))))

(clojure.spec.alpha/def :portkey.aws.lex-models.put-slot-type-request/name (clojure.spec.alpha/and :portkey.aws.lex-models/slot-type-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-slot-type-request/description (clojure.spec.alpha/and :portkey.aws.lex-models/description))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-slot-type-request/enumeration-values (clojure.spec.alpha/and :portkey.aws.lex-models/enumeration-values))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-slot-type-request/checksum (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models/put-slot-type-request (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.put-slot-type-request/name] :opt-un [:portkey.aws.lex-models.put-slot-type-request/description :portkey.aws.lex-models.put-slot-type-request/enumerationValues :portkey.aws.lex-models.put-slot-type-request/checksum]))

(clojure.spec.alpha/def :portkey.aws.lex-models.create-intent-version-request/name (clojure.spec.alpha/and :portkey.aws.lex-models/intent-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-intent-version-request/checksum (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models/create-intent-version-request (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.create-intent-version-request/name] :opt-un [:portkey.aws.lex-models.create-intent-version-request/checksum]))

(clojure.spec.alpha/def :portkey.aws.lex-models.resource-in-use-exception/reference-type (clojure.spec.alpha/and :portkey.aws.lex-models/reference-type))
(clojure.spec.alpha/def :portkey.aws.lex-models.resource-in-use-exception/example-reference (clojure.spec.alpha/and :portkey.aws.lex-models/resource-reference))
(clojure.spec.alpha/def :portkey.aws.lex-models/resource-in-use-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.resource-in-use-exception/referenceType :portkey.aws.lex-models.resource-in-use-exception/exampleReference]))

(clojure.spec.alpha/def :portkey.aws.lex-models.code-hook/uri (clojure.spec.alpha/and :portkey.aws.lex-models/lambdaarn))
(clojure.spec.alpha/def :portkey.aws.lex-models.code-hook/message-version (clojure.spec.alpha/and :portkey.aws.lex-models/message-version))
(clojure.spec.alpha/def :portkey.aws.lex-models/code-hook (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.code-hook/uri :portkey.aws.lex-models.code-hook/messageVersion] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lex-models/count (clojure.spec.alpha/and clojure.core/int?))

(clojure.spec.alpha/def :portkey.aws.lex-models/intent-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__30837__auto__] (clojure.core/<= 1 (clojure.core/count s__30837__auto__))) (clojure.core/fn [s__30838__auto__] (clojure.core/< (clojure.core/count s__30838__auto__) 100)) (clojure.core/fn [s__30839__auto__] (clojure.core/re-matches #"^[a-zA-Z]+((_[a-zA-Z]+)*|([a-zA-Z]+_)*|_)" s__30839__auto__))))

(clojure.spec.alpha/def :portkey.aws.lex-models.limit-exceeded-exception/retry-after-seconds (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models.limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models/limit-exceeded-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.limit-exceeded-exception/retryAfterSeconds :portkey.aws.lex-models.limit-exceeded-exception/message]))

(clojure.spec.alpha/def :portkey.aws.lex-models.create-slot-type-version-request/name (clojure.spec.alpha/and :portkey.aws.lex-models/slot-type-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-slot-type-version-request/checksum (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models/create-slot-type-version-request (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.create-slot-type-version-request/name] :opt-un [:portkey.aws.lex-models.create-slot-type-version-request/checksum]))

(clojure.spec.alpha/def :portkey.aws.lex-models/slot-utterance-list (clojure.spec.alpha/coll-of :portkey.aws.lex-models/utterance :max-count 10))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-slot-types-request/next-token (clojure.spec.alpha/and :portkey.aws.lex-models/next-token))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-slot-types-request/max-results (clojure.spec.alpha/and :portkey.aws.lex-models/max-results))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-slot-types-request/name-contains (clojure.spec.alpha/and :portkey.aws.lex-models/slot-type-name))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-slot-types-request (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.get-slot-types-request/nextToken :portkey.aws.lex-models.get-slot-types-request/maxResults :portkey.aws.lex-models.get-slot-types-request/nameContains]))

(clojure.spec.alpha/def :portkey.aws.lex-models/response-card (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__30837__auto__] (clojure.core/<= 1 (clojure.core/count s__30837__auto__))) (clojure.core/fn [s__30838__auto__] (clojure.core/< (clojure.core/count s__30838__auto__) 50000))))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-builtin-intents-request/locale (clojure.spec.alpha/and :portkey.aws.lex-models/locale))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-builtin-intents-request/signature-contains (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-builtin-intents-request/next-token (clojure.spec.alpha/and :portkey.aws.lex-models/next-token))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-builtin-intents-request/max-results (clojure.spec.alpha/and :portkey.aws.lex-models/max-results))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-builtin-intents-request (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.get-builtin-intents-request/locale :portkey.aws.lex-models.get-builtin-intents-request/signatureContains :portkey.aws.lex-models.get-builtin-intents-request/nextToken :portkey.aws.lex-models.get-builtin-intents-request/maxResults]))

(clojure.spec.alpha/def :portkey.aws.lex-models.delete-bot-alias-request/name (clojure.spec.alpha/and :portkey.aws.lex-models/alias-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.delete-bot-alias-request/bot-name (clojure.spec.alpha/and :portkey.aws.lex-models/bot-name))
(clojure.spec.alpha/def :portkey.aws.lex-models/delete-bot-alias-request (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.delete-bot-alias-request/name :portkey.aws.lex-models.delete-bot-alias-request/botName] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lex-models/status (clojure.spec.alpha/conformer (clojure.core/let [m__30835__auto__ {"BUILDING" "BUILDING", :building "BUILDING", "READY" "READY", :ready "READY", "FAILED" "FAILED", :failed "FAILED", "NOT_BUILT" "NOT_BUILT", :not-built "NOT_BUILT"}] (clojure.core/fn [s__30836__auto__] (m__30835__auto__ s__30836__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.awsgen/dashed)))

(clojure.spec.alpha/def :portkey.aws.lex-models/next-token (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.lex-models/priority (clojure.spec.alpha/and clojure.core/int? (fn* [p1__30878__30879__auto__] (clojure.core/<= 0 p1__30878__30879__auto__)) (fn* [p1__30880__30881__auto__] (clojure.core/<= p1__30880__30881__auto__ 100))))

(clojure.spec.alpha/def :portkey.aws.lex-models/status-type (clojure.spec.alpha/conformer (clojure.core/let [m__30835__auto__ {"Detected" "Detected", :detected "Detected", "Missed" "Missed", :missed "Missed"}] (clojure.core/fn [s__30836__auto__] (m__30835__auto__ s__30836__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.awsgen/dashed)))

(clojure.spec.alpha/def :portkey.aws.lex-models/utterance-string (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__30837__auto__] (clojure.core/<= 1 (clojure.core/count s__30837__auto__))) (clojure.core/fn [s__30838__auto__] (clojure.core/< (clojure.core/count s__30838__auto__) 2000))))

(clojure.spec.alpha/def :portkey.aws.lex-models.delete-slot-type-version-request/name (clojure.spec.alpha/and :portkey.aws.lex-models/slot-type-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.delete-slot-type-version-request/version (clojure.spec.alpha/and :portkey.aws.lex-models/numerical-version))
(clojure.spec.alpha/def :portkey.aws.lex-models/delete-slot-type-version-request (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.delete-slot-type-version-request/name :portkey.aws.lex-models.delete-slot-type-version-request/version] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lex-models.delete-bot-version-request/name (clojure.spec.alpha/and :portkey.aws.lex-models/bot-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.delete-bot-version-request/version (clojure.spec.alpha/and :portkey.aws.lex-models/numerical-version))
(clojure.spec.alpha/def :portkey.aws.lex-models/delete-bot-version-request (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.delete-bot-version-request/name :portkey.aws.lex-models.delete-bot-version-request/version] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lex-models/bot-versions (clojure.spec.alpha/coll-of :portkey.aws.lex-models/version :max-count 5))

(clojure.spec.alpha/def :portkey.aws.lex-models/content-type (clojure.spec.alpha/conformer (clojure.core/let [m__30835__auto__ {"PlainText" "PlainText", :plain-text "PlainText", "SSML" "SSML", :ssml "SSML"}] (clojure.core/fn [s__30836__auto__] (m__30835__auto__ s__30836__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.awsgen/dashed)))

(clojure.spec.alpha/def :portkey.aws.lex-models/sessionttl (clojure.spec.alpha/and clojure.core/int? (fn* [p1__30878__30879__auto__] (clojure.core/<= 60 p1__30878__30879__auto__)) (fn* [p1__30880__30881__auto__] (clojure.core/<= p1__30880__30881__auto__ 86400))))

(clojure.spec.alpha/def :portkey.aws.lex-models/bot-alias-metadata-list (clojure.spec.alpha/coll-of :portkey.aws.lex-models/bot-alias-metadata :max-count nil))

(clojure.spec.alpha/def :portkey.aws.lex-models/content-string (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__30837__auto__] (clojure.core/<= 1 (clojure.core/count s__30837__auto__))) (clojure.core/fn [s__30838__auto__] (clojure.core/< (clojure.core/count s__30838__auto__) 1000))))

(clojure.spec.alpha/def :portkey.aws.lex-models.internal-failure-exception/message (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models/internal-failure-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.internal-failure-exception/message]))

(clojure.spec.alpha/def :portkey.aws.lex-models.follow-up-prompt/prompt (clojure.spec.alpha/and :portkey.aws.lex-models/prompt))
(clojure.spec.alpha/def :portkey.aws.lex-models.follow-up-prompt/rejection-statement (clojure.spec.alpha/and :portkey.aws.lex-models/statement))
(clojure.spec.alpha/def :portkey.aws.lex-models/follow-up-prompt (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.follow-up-prompt/prompt :portkey.aws.lex-models.follow-up-prompt/rejectionStatement] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-channel-association-request/name (clojure.spec.alpha/and :portkey.aws.lex-models/bot-channel-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-channel-association-request/bot-name (clojure.spec.alpha/and :portkey.aws.lex-models/bot-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-channel-association-request/bot-alias (clojure.spec.alpha/and :portkey.aws.lex-models/alias-name))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-bot-channel-association-request (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.get-bot-channel-association-request/name :portkey.aws.lex-models.get-bot-channel-association-request/botName :portkey.aws.lex-models.get-bot-channel-association-request/botAlias] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lex-models/builtin-intent-signature (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.lex-models.builtin-intent-slot/name (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models/builtin-intent-slot (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.builtin-intent-slot/name]))

(clojure.spec.alpha/def :portkey.aws.lex-models.create-bot-version-response/intents (clojure.spec.alpha/and :portkey.aws.lex-models/intent-list))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-bot-version-response/created-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-bot-version-response/idle-sessionttlin-seconds (clojure.spec.alpha/and :portkey.aws.lex-models/sessionttl))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-bot-version-response/clarification-prompt (clojure.spec.alpha/and :portkey.aws.lex-models/prompt))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-bot-version-response/name (clojure.spec.alpha/and :portkey.aws.lex-models/bot-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-bot-version-response/locale (clojure.spec.alpha/and :portkey.aws.lex-models/locale))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-bot-version-response/last-updated-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-bot-version-response/status (clojure.spec.alpha/and :portkey.aws.lex-models/status))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-bot-version-response/abort-statement (clojure.spec.alpha/and :portkey.aws.lex-models/statement))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-bot-version-response/version (clojure.spec.alpha/and :portkey.aws.lex-models/version))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-bot-version-response/failure-reason (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-bot-version-response/child-directed (clojure.spec.alpha/and :portkey.aws.lex-models/boolean))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-bot-version-response/checksum (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-bot-version-response/voice-id (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-bot-version-response/description (clojure.spec.alpha/and :portkey.aws.lex-models/description))
(clojure.spec.alpha/def :portkey.aws.lex-models/create-bot-version-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.create-bot-version-response/intents :portkey.aws.lex-models.create-bot-version-response/createdDate :portkey.aws.lex-models.create-bot-version-response/idleSessionTTLInSeconds :portkey.aws.lex-models.create-bot-version-response/clarificationPrompt :portkey.aws.lex-models.create-bot-version-response/name :portkey.aws.lex-models.create-bot-version-response/locale :portkey.aws.lex-models.create-bot-version-response/lastUpdatedDate :portkey.aws.lex-models.create-bot-version-response/status :portkey.aws.lex-models.create-bot-version-response/abortStatement :portkey.aws.lex-models.create-bot-version-response/version :portkey.aws.lex-models.create-bot-version-response/failureReason :portkey.aws.lex-models.create-bot-version-response/childDirected :portkey.aws.lex-models.create-bot-version-response/checksum :portkey.aws.lex-models.create-bot-version-response/voiceId :portkey.aws.lex-models.create-bot-version-response/description]))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-intents-request/next-token (clojure.spec.alpha/and :portkey.aws.lex-models/next-token))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-intents-request/max-results (clojure.spec.alpha/and :portkey.aws.lex-models/max-results))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-intents-request/name-contains (clojure.spec.alpha/and :portkey.aws.lex-models/intent-name))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-intents-request (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.get-intents-request/nextToken :portkey.aws.lex-models.get-intents-request/maxResults :portkey.aws.lex-models.get-intents-request/nameContains]))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-slot-type-versions-response/slot-types (clojure.spec.alpha/and :portkey.aws.lex-models/slot-type-metadata-list))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-slot-type-versions-response/next-token (clojure.spec.alpha/and :portkey.aws.lex-models/next-token))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-slot-type-versions-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.get-slot-type-versions-response/slotTypes :portkey.aws.lex-models.get-slot-type-versions-response/nextToken]))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-versions-request/name (clojure.spec.alpha/and :portkey.aws.lex-models/bot-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-versions-request/next-token (clojure.spec.alpha/and :portkey.aws.lex-models/next-token))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-versions-request/max-results (clojure.spec.alpha/and :portkey.aws.lex-models/max-results))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-bot-versions-request (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.get-bot-versions-request/name] :opt-un [:portkey.aws.lex-models.get-bot-versions-request/nextToken :portkey.aws.lex-models.get-bot-versions-request/maxResults]))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-intent-versions-response/intents (clojure.spec.alpha/and :portkey.aws.lex-models/intent-metadata-list))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-intent-versions-response/next-token (clojure.spec.alpha/and :portkey.aws.lex-models/next-token))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-intent-versions-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.get-intent-versions-response/intents :portkey.aws.lex-models.get-intent-versions-response/nextToken]))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-slot-type-versions-request/name (clojure.spec.alpha/and :portkey.aws.lex-models/slot-type-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-slot-type-versions-request/next-token (clojure.spec.alpha/and :portkey.aws.lex-models/next-token))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-slot-type-versions-request/max-results (clojure.spec.alpha/and :portkey.aws.lex-models/max-results))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-slot-type-versions-request (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.get-slot-type-versions-request/name] :opt-un [:portkey.aws.lex-models.get-slot-type-versions-request/nextToken :portkey.aws.lex-models.get-slot-type-versions-request/maxResults]))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-response/intents (clojure.spec.alpha/and :portkey.aws.lex-models/intent-list))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-response/created-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-response/idle-sessionttlin-seconds (clojure.spec.alpha/and :portkey.aws.lex-models/sessionttl))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-response/clarification-prompt (clojure.spec.alpha/and :portkey.aws.lex-models/prompt))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-response/name (clojure.spec.alpha/and :portkey.aws.lex-models/bot-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-response/locale (clojure.spec.alpha/and :portkey.aws.lex-models/locale))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-response/last-updated-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-response/status (clojure.spec.alpha/and :portkey.aws.lex-models/status))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-response/abort-statement (clojure.spec.alpha/and :portkey.aws.lex-models/statement))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-response/version (clojure.spec.alpha/and :portkey.aws.lex-models/version))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-response/failure-reason (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-response/child-directed (clojure.spec.alpha/and :portkey.aws.lex-models/boolean))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-response/checksum (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-response/voice-id (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-response/description (clojure.spec.alpha/and :portkey.aws.lex-models/description))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-bot-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.get-bot-response/intents :portkey.aws.lex-models.get-bot-response/createdDate :portkey.aws.lex-models.get-bot-response/idleSessionTTLInSeconds :portkey.aws.lex-models.get-bot-response/clarificationPrompt :portkey.aws.lex-models.get-bot-response/name :portkey.aws.lex-models.get-bot-response/locale :portkey.aws.lex-models.get-bot-response/lastUpdatedDate :portkey.aws.lex-models.get-bot-response/status :portkey.aws.lex-models.get-bot-response/abortStatement :portkey.aws.lex-models.get-bot-response/version :portkey.aws.lex-models.get-bot-response/failureReason :portkey.aws.lex-models.get-bot-response/childDirected :portkey.aws.lex-models.get-bot-response/checksum :portkey.aws.lex-models.get-bot-response/voiceId :portkey.aws.lex-models.get-bot-response/description]))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-builtin-slot-types-request/locale (clojure.spec.alpha/and :portkey.aws.lex-models/locale))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-builtin-slot-types-request/signature-contains (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-builtin-slot-types-request/next-token (clojure.spec.alpha/and :portkey.aws.lex-models/next-token))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-builtin-slot-types-request/max-results (clojure.spec.alpha/and :portkey.aws.lex-models/max-results))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-builtin-slot-types-request (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.get-builtin-slot-types-request/locale :portkey.aws.lex-models.get-builtin-slot-types-request/signatureContains :portkey.aws.lex-models.get-builtin-slot-types-request/nextToken :portkey.aws.lex-models.get-builtin-slot-types-request/maxResults]))

(clojure.spec.alpha/def :portkey.aws.lex-models/intent-list (clojure.spec.alpha/coll-of :portkey.aws.lex-models/intent :max-count 100))

(clojure.spec.alpha/def :portkey.aws.lex-models/fulfillment-activity-type (clojure.spec.alpha/conformer (clojure.core/let [m__30835__auto__ {"ReturnIntent" "ReturnIntent", :return-intent "ReturnIntent", "CodeHook" "CodeHook", :code-hook "CodeHook"}] (clojure.core/fn [s__30836__auto__] (m__30835__auto__ s__30836__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.awsgen/dashed)))

(clojure.spec.alpha/def :portkey.aws.lex-models/bot-channel-association-list (clojure.spec.alpha/coll-of :portkey.aws.lex-models/bot-channel-association :max-count nil))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-intents-response/intents (clojure.spec.alpha/and :portkey.aws.lex-models/intent-metadata-list))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-intents-response/next-token (clojure.spec.alpha/and :portkey.aws.lex-models/next-token))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-intents-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.get-intents-response/intents :portkey.aws.lex-models.get-intents-response/nextToken]))

(clojure.spec.alpha/def :portkey.aws.lex-models.conflict-exception/message (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models/conflict-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.conflict-exception/message]))

(clojure.spec.alpha/def :portkey.aws.lex-models/utterance (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__30837__auto__] (clojure.core/<= 1 (clojure.core/count s__30837__auto__))) (clojure.core/fn [s__30838__auto__] (clojure.core/< (clojure.core/count s__30838__auto__) 200))))

(clojure.spec.alpha/def :portkey.aws.lex-models/value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__30837__auto__] (clojure.core/<= 1 (clojure.core/count s__30837__auto__))) (clojure.core/fn [s__30838__auto__] (clojure.core/< (clojure.core/count s__30838__auto__) 140))))

(clojure.spec.alpha/def :portkey.aws.lex-models/list-of-utterance (clojure.spec.alpha/coll-of :portkey.aws.lex-models/utterance-data :max-count nil))

(clojure.spec.alpha/def :portkey.aws.lex-models/description (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__30837__auto__] (clojure.core/<= 0 (clojure.core/count s__30837__auto__))) (clojure.core/fn [s__30838__auto__] (clojure.core/< (clojure.core/count s__30838__auto__) 200))))

(clojure.spec.alpha/def :portkey.aws.lex-models.put-slot-type-response/name (clojure.spec.alpha/and :portkey.aws.lex-models/slot-type-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-slot-type-response/description (clojure.spec.alpha/and :portkey.aws.lex-models/description))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-slot-type-response/enumeration-values (clojure.spec.alpha/and :portkey.aws.lex-models/enumeration-values))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-slot-type-response/last-updated-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-slot-type-response/created-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-slot-type-response/version (clojure.spec.alpha/and :portkey.aws.lex-models/version))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-slot-type-response/checksum (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models/put-slot-type-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.put-slot-type-response/name :portkey.aws.lex-models.put-slot-type-response/description :portkey.aws.lex-models.put-slot-type-response/enumerationValues :portkey.aws.lex-models.put-slot-type-response/lastUpdatedDate :portkey.aws.lex-models.put-slot-type-response/createdDate :portkey.aws.lex-models.put-slot-type-response/version :portkey.aws.lex-models.put-slot-type-response/checksum]))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-channel-associations-response/bot-channel-associations (clojure.spec.alpha/and :portkey.aws.lex-models/bot-channel-association-list))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-channel-associations-response/next-token (clojure.spec.alpha/and :portkey.aws.lex-models/next-token))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-bot-channel-associations-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.get-bot-channel-associations-response/botChannelAssociations :portkey.aws.lex-models.get-bot-channel-associations-response/nextToken]))

(clojure.spec.alpha/def :portkey.aws.lex-models.message/content-type (clojure.spec.alpha/and :portkey.aws.lex-models/content-type))
(clojure.spec.alpha/def :portkey.aws.lex-models.message/content (clojure.spec.alpha/and :portkey.aws.lex-models/content-string))
(clojure.spec.alpha/def :portkey.aws.lex-models/message (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.message/contentType :portkey.aws.lex-models.message/content] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-builtin-intent-request/signature (clojure.spec.alpha/and :portkey.aws.lex-models/builtin-intent-signature))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-builtin-intent-request (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.get-builtin-intent-request/signature] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lex-models/slot-type-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__30837__auto__] (clojure.core/<= 1 (clojure.core/count s__30837__auto__))) (clojure.core/fn [s__30838__auto__] (clojure.core/< (clojure.core/count s__30838__auto__) 100)) (clojure.core/fn [s__30839__auto__] (clojure.core/re-matches #"^[a-zA-Z]+((_[a-zA-Z]+)*|([a-zA-Z]+_)*|_)" s__30839__auto__))))

(clojure.spec.alpha/def :portkey.aws.lex-models.not-found-exception/message (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models/not-found-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.not-found-exception/message]))

(clojure.spec.alpha/def :portkey.aws.lex-models.delete-utterances-request/bot-name (clojure.spec.alpha/and :portkey.aws.lex-models/bot-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.delete-utterances-request/user-id (clojure.spec.alpha/and :portkey.aws.lex-models/user-id))
(clojure.spec.alpha/def :portkey.aws.lex-models/delete-utterances-request (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.delete-utterances-request/botName :portkey.aws.lex-models.delete-utterances-request/userId] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lex-models/custom-or-builtin-slot-type-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__30837__auto__] (clojure.core/<= 1 (clojure.core/count s__30837__auto__))) (clojure.core/fn [s__30838__auto__] (clojure.core/< (clojure.core/count s__30838__auto__) 100)) (clojure.core/fn [s__30839__auto__] (clojure.core/re-matches #"^([a-zA-Z]|AMAZON.)+((_[a-zA-Z]+)*|([a-zA-Z]+_)*|_)" s__30839__auto__))))

(clojure.spec.alpha/def :portkey.aws.lex-models/enumeration-values (clojure.spec.alpha/coll-of :portkey.aws.lex-models/enumeration-value :max-count 10000))

(clojure.spec.alpha/def :portkey.aws.lex-models/bot-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__30837__auto__] (clojure.core/<= 2 (clojure.core/count s__30837__auto__))) (clojure.core/fn [s__30838__auto__] (clojure.core/< (clojure.core/count s__30838__auto__) 50)) (clojure.core/fn [s__30839__auto__] (clojure.core/re-matches #"^[a-zA-Z]+((_[a-zA-Z]+)*|([a-zA-Z]+_)*|_)" s__30839__auto__))))

(clojure.spec.alpha/def :portkey.aws.lex-models/string (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.lex-models.slot/priority (clojure.spec.alpha/and :portkey.aws.lex-models/priority))
(clojure.spec.alpha/def :portkey.aws.lex-models.slot/response-card (clojure.spec.alpha/and :portkey.aws.lex-models/response-card))
(clojure.spec.alpha/def :portkey.aws.lex-models.slot/slot-type (clojure.spec.alpha/and :portkey.aws.lex-models/custom-or-builtin-slot-type-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.slot/name (clojure.spec.alpha/and :portkey.aws.lex-models/slot-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.slot/slot-constraint (clojure.spec.alpha/and :portkey.aws.lex-models/slot-constraint))
(clojure.spec.alpha/def :portkey.aws.lex-models.slot/slot-type-version (clojure.spec.alpha/and :portkey.aws.lex-models/version))
(clojure.spec.alpha/def :portkey.aws.lex-models.slot/sample-utterances (clojure.spec.alpha/and :portkey.aws.lex-models/slot-utterance-list))
(clojure.spec.alpha/def :portkey.aws.lex-models.slot/value-elicitation-prompt (clojure.spec.alpha/and :portkey.aws.lex-models/prompt))
(clojure.spec.alpha/def :portkey.aws.lex-models.slot/description (clojure.spec.alpha/and :portkey.aws.lex-models/description))
(clojure.spec.alpha/def :portkey.aws.lex-models/slot (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.slot/name :portkey.aws.lex-models.slot/slotConstraint] :opt-un [:portkey.aws.lex-models.slot/priority :portkey.aws.lex-models.slot/responseCard :portkey.aws.lex-models.slot/slotType :portkey.aws.lex-models.slot/slotTypeVersion :portkey.aws.lex-models.slot/sampleUtterances :portkey.aws.lex-models.slot/valueElicitationPrompt :portkey.aws.lex-models.slot/description]))

(clojure.spec.alpha/def :portkey.aws.lex-models/builtin-slot-type-metadata-list (clojure.spec.alpha/coll-of :portkey.aws.lex-models/builtin-slot-type-metadata :max-count nil))

(clojure.spec.alpha/def :portkey.aws.lex-models.delete-bot-request/name (clojure.spec.alpha/and :portkey.aws.lex-models/bot-name))
(clojure.spec.alpha/def :portkey.aws.lex-models/delete-bot-request (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.delete-bot-request/name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lex-models/slot-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__30837__auto__] (clojure.core/<= 1 (clojure.core/count s__30837__auto__))) (clojure.core/fn [s__30838__auto__] (clojure.core/< (clojure.core/count s__30838__auto__) 100)) (clojure.core/fn [s__30839__auto__] (clojure.core/re-matches #"^[a-zA-Z]+(((_|.)[a-zA-Z]+)*|([a-zA-Z]+(_|.))*|(_|.))" s__30839__auto__))))

(clojure.spec.alpha/def :portkey.aws.lex-models.delete-intent-request/name (clojure.spec.alpha/and :portkey.aws.lex-models/intent-name))
(clojure.spec.alpha/def :portkey.aws.lex-models/delete-intent-request (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.delete-intent-request/name] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lex-models.put-intent-response/follow-up-prompt (clojure.spec.alpha/and :portkey.aws.lex-models/follow-up-prompt))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-intent-response/fulfillment-activity (clojure.spec.alpha/and :portkey.aws.lex-models/fulfillment-activity))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-intent-response/slots (clojure.spec.alpha/and :portkey.aws.lex-models/slot-list))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-intent-response/parent-intent-signature (clojure.spec.alpha/and :portkey.aws.lex-models/builtin-intent-signature))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-intent-response/confirmation-prompt (clojure.spec.alpha/and :portkey.aws.lex-models/prompt))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-intent-response/created-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-intent-response/name (clojure.spec.alpha/and :portkey.aws.lex-models/intent-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-intent-response/rejection-statement (clojure.spec.alpha/and :portkey.aws.lex-models/statement))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-intent-response/last-updated-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-intent-response/dialog-code-hook (clojure.spec.alpha/and :portkey.aws.lex-models/code-hook))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-intent-response/conclusion-statement (clojure.spec.alpha/and :portkey.aws.lex-models/statement))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-intent-response/sample-utterances (clojure.spec.alpha/and :portkey.aws.lex-models/intent-utterance-list))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-intent-response/version (clojure.spec.alpha/and :portkey.aws.lex-models/version))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-intent-response/checksum (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-intent-response/description (clojure.spec.alpha/and :portkey.aws.lex-models/description))
(clojure.spec.alpha/def :portkey.aws.lex-models/put-intent-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.put-intent-response/followUpPrompt :portkey.aws.lex-models.put-intent-response/fulfillmentActivity :portkey.aws.lex-models.put-intent-response/slots :portkey.aws.lex-models.put-intent-response/parentIntentSignature :portkey.aws.lex-models.put-intent-response/confirmationPrompt :portkey.aws.lex-models.put-intent-response/createdDate :portkey.aws.lex-models.put-intent-response/name :portkey.aws.lex-models.put-intent-response/rejectionStatement :portkey.aws.lex-models.put-intent-response/lastUpdatedDate :portkey.aws.lex-models.put-intent-response/dialogCodeHook :portkey.aws.lex-models.put-intent-response/conclusionStatement :portkey.aws.lex-models.put-intent-response/sampleUtterances :portkey.aws.lex-models.put-intent-response/version :portkey.aws.lex-models.put-intent-response/checksum :portkey.aws.lex-models.put-intent-response/description]))

(clojure.spec.alpha/def :portkey.aws.lex-models.delete-bot-channel-association-request/name (clojure.spec.alpha/and :portkey.aws.lex-models/bot-channel-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.delete-bot-channel-association-request/bot-name (clojure.spec.alpha/and :portkey.aws.lex-models/bot-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.delete-bot-channel-association-request/bot-alias (clojure.spec.alpha/and :portkey.aws.lex-models/alias-name))
(clojure.spec.alpha/def :portkey.aws.lex-models/delete-bot-channel-association-request (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.delete-bot-channel-association-request/name :portkey.aws.lex-models.delete-bot-channel-association-request/botName :portkey.aws.lex-models.delete-bot-channel-association-request/botAlias] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lex-models/builtin-slot-type-signature (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.lex-models.fulfillment-activity/type (clojure.spec.alpha/and :portkey.aws.lex-models/fulfillment-activity-type))
(clojure.spec.alpha/def :portkey.aws.lex-models.fulfillment-activity/code-hook (clojure.spec.alpha/and :portkey.aws.lex-models/code-hook))
(clojure.spec.alpha/def :portkey.aws.lex-models/fulfillment-activity (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.fulfillment-activity/type] :opt-un [:portkey.aws.lex-models.fulfillment-activity/codeHook]))

(clojure.spec.alpha/def :portkey.aws.lex-models/message-list (clojure.spec.alpha/coll-of :portkey.aws.lex-models/message :max-count 5))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-intent-versions-request/name (clojure.spec.alpha/and :portkey.aws.lex-models/intent-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-intent-versions-request/next-token (clojure.spec.alpha/and :portkey.aws.lex-models/next-token))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-intent-versions-request/max-results (clojure.spec.alpha/and :portkey.aws.lex-models/max-results))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-intent-versions-request (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.get-intent-versions-request/name] :opt-un [:portkey.aws.lex-models.get-intent-versions-request/nextToken :portkey.aws.lex-models.get-intent-versions-request/maxResults]))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-intent-request/name (clojure.spec.alpha/and :portkey.aws.lex-models/intent-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-intent-request/version (clojure.spec.alpha/and :portkey.aws.lex-models/version))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-intent-request (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.get-intent-request/name :portkey.aws.lex-models.get-intent-request/version] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-intent-response/follow-up-prompt (clojure.spec.alpha/and :portkey.aws.lex-models/follow-up-prompt))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-intent-response/fulfillment-activity (clojure.spec.alpha/and :portkey.aws.lex-models/fulfillment-activity))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-intent-response/slots (clojure.spec.alpha/and :portkey.aws.lex-models/slot-list))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-intent-response/parent-intent-signature (clojure.spec.alpha/and :portkey.aws.lex-models/builtin-intent-signature))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-intent-response/confirmation-prompt (clojure.spec.alpha/and :portkey.aws.lex-models/prompt))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-intent-response/created-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-intent-response/name (clojure.spec.alpha/and :portkey.aws.lex-models/intent-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-intent-response/rejection-statement (clojure.spec.alpha/and :portkey.aws.lex-models/statement))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-intent-response/last-updated-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-intent-response/dialog-code-hook (clojure.spec.alpha/and :portkey.aws.lex-models/code-hook))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-intent-response/conclusion-statement (clojure.spec.alpha/and :portkey.aws.lex-models/statement))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-intent-response/sample-utterances (clojure.spec.alpha/and :portkey.aws.lex-models/intent-utterance-list))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-intent-response/version (clojure.spec.alpha/and :portkey.aws.lex-models/version))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-intent-response/checksum (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-intent-response/description (clojure.spec.alpha/and :portkey.aws.lex-models/description))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-intent-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.get-intent-response/followUpPrompt :portkey.aws.lex-models.get-intent-response/fulfillmentActivity :portkey.aws.lex-models.get-intent-response/slots :portkey.aws.lex-models.get-intent-response/parentIntentSignature :portkey.aws.lex-models.get-intent-response/confirmationPrompt :portkey.aws.lex-models.get-intent-response/createdDate :portkey.aws.lex-models.get-intent-response/name :portkey.aws.lex-models.get-intent-response/rejectionStatement :portkey.aws.lex-models.get-intent-response/lastUpdatedDate :portkey.aws.lex-models.get-intent-response/dialogCodeHook :portkey.aws.lex-models.get-intent-response/conclusionStatement :portkey.aws.lex-models.get-intent-response/sampleUtterances :portkey.aws.lex-models.get-intent-response/version :portkey.aws.lex-models.get-intent-response/checksum :portkey.aws.lex-models.get-intent-response/description]))

(clojure.spec.alpha/def :portkey.aws.lex-models.intent-metadata/name (clojure.spec.alpha/and :portkey.aws.lex-models/intent-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.intent-metadata/description (clojure.spec.alpha/and :portkey.aws.lex-models/description))
(clojure.spec.alpha/def :portkey.aws.lex-models.intent-metadata/last-updated-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.intent-metadata/created-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.intent-metadata/version (clojure.spec.alpha/and :portkey.aws.lex-models/version))
(clojure.spec.alpha/def :portkey.aws.lex-models/intent-metadata (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.intent-metadata/name :portkey.aws.lex-models.intent-metadata/description :portkey.aws.lex-models.intent-metadata/lastUpdatedDate :portkey.aws.lex-models.intent-metadata/createdDate :portkey.aws.lex-models.intent-metadata/version]))

(clojure.spec.alpha/def :portkey.aws.lex-models/timestamp clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.lex-models/slot-constraint (clojure.spec.alpha/conformer (clojure.core/let [m__30835__auto__ {"Required" "Required", :required "Required", "Optional" "Optional", :optional "Optional"}] (clojure.core/fn [s__30836__auto__] (m__30835__auto__ s__30836__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.awsgen/dashed)))

(clojure.spec.alpha/def :portkey.aws.lex-models.slot-type-metadata/name (clojure.spec.alpha/and :portkey.aws.lex-models/slot-type-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.slot-type-metadata/description (clojure.spec.alpha/and :portkey.aws.lex-models/description))
(clojure.spec.alpha/def :portkey.aws.lex-models.slot-type-metadata/last-updated-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.slot-type-metadata/created-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.slot-type-metadata/version (clojure.spec.alpha/and :portkey.aws.lex-models/version))
(clojure.spec.alpha/def :portkey.aws.lex-models/slot-type-metadata (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.slot-type-metadata/name :portkey.aws.lex-models.slot-type-metadata/description :portkey.aws.lex-models.slot-type-metadata/lastUpdatedDate :portkey.aws.lex-models.slot-type-metadata/createdDate :portkey.aws.lex-models.slot-type-metadata/version]))

(clojure.spec.alpha/def :portkey.aws.lex-models/intent-metadata-list (clojure.spec.alpha/coll-of :portkey.aws.lex-models/intent-metadata :max-count nil))

(clojure.spec.alpha/def :portkey.aws.lex-models/message-version (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__30837__auto__] (clojure.core/<= 1 (clojure.core/count s__30837__auto__))) (clojure.core/fn [s__30838__auto__] (clojure.core/< (clojure.core/count s__30838__auto__) 5))))

(clojure.spec.alpha/def :portkey.aws.lex-models/slot-type-metadata-list (clojure.spec.alpha/coll-of :portkey.aws.lex-models/slot-type-metadata :max-count nil))

(clojure.spec.alpha/def :portkey.aws.lex-models.put-intent-request/follow-up-prompt (clojure.spec.alpha/and :portkey.aws.lex-models/follow-up-prompt))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-intent-request/fulfillment-activity (clojure.spec.alpha/and :portkey.aws.lex-models/fulfillment-activity))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-intent-request/slots (clojure.spec.alpha/and :portkey.aws.lex-models/slot-list))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-intent-request/parent-intent-signature (clojure.spec.alpha/and :portkey.aws.lex-models/builtin-intent-signature))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-intent-request/confirmation-prompt (clojure.spec.alpha/and :portkey.aws.lex-models/prompt))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-intent-request/name (clojure.spec.alpha/and :portkey.aws.lex-models/intent-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-intent-request/rejection-statement (clojure.spec.alpha/and :portkey.aws.lex-models/statement))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-intent-request/dialog-code-hook (clojure.spec.alpha/and :portkey.aws.lex-models/code-hook))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-intent-request/conclusion-statement (clojure.spec.alpha/and :portkey.aws.lex-models/statement))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-intent-request/sample-utterances (clojure.spec.alpha/and :portkey.aws.lex-models/intent-utterance-list))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-intent-request/checksum (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models.put-intent-request/description (clojure.spec.alpha/and :portkey.aws.lex-models/description))
(clojure.spec.alpha/def :portkey.aws.lex-models/put-intent-request (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.put-intent-request/name] :opt-un [:portkey.aws.lex-models.put-intent-request/followUpPrompt :portkey.aws.lex-models.put-intent-request/fulfillmentActivity :portkey.aws.lex-models.put-intent-request/slots :portkey.aws.lex-models.put-intent-request/parentIntentSignature :portkey.aws.lex-models.put-intent-request/confirmationPrompt :portkey.aws.lex-models.put-intent-request/rejectionStatement :portkey.aws.lex-models.put-intent-request/dialogCodeHook :portkey.aws.lex-models.put-intent-request/conclusionStatement :portkey.aws.lex-models.put-intent-request/sampleUtterances :portkey.aws.lex-models.put-intent-request/checksum :portkey.aws.lex-models.put-intent-request/description]))

(clojure.spec.alpha/def :portkey.aws.lex-models/reference-type (clojure.spec.alpha/conformer (clojure.core/let [m__30835__auto__ {"Intent" "Intent", :intent "Intent", "Bot" "Bot", :bot "Bot", "BotAlias" "BotAlias", :bot-alias "BotAlias", "BotChannel" "BotChannel", :bot-channel "BotChannel"}] (clojure.core/fn [s__30836__auto__] (m__30835__auto__ s__30836__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.awsgen/dashed)))

(clojure.spec.alpha/def :portkey.aws.lex-models/max-results (clojure.spec.alpha/and clojure.core/int? (fn* [p1__30878__30879__auto__] (clojure.core/<= 1 p1__30878__30879__auto__)) (fn* [p1__30880__30881__auto__] (clojure.core/<= p1__30880__30881__auto__ 50))))

(clojure.spec.alpha/def :portkey.aws.lex-models/version (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__30837__auto__] (clojure.core/<= 1 (clojure.core/count s__30837__auto__))) (clojure.core/fn [s__30838__auto__] (clojure.core/< (clojure.core/count s__30838__auto__) 64)) (clojure.core/fn [s__30839__auto__] (clojure.core/re-matches #"\$LATEST|[0-9]+" s__30839__auto__))))

(clojure.spec.alpha/def :portkey.aws.lex-models.builtin-intent-metadata/signature (clojure.spec.alpha/and :portkey.aws.lex-models/builtin-intent-signature))
(clojure.spec.alpha/def :portkey.aws.lex-models.builtin-intent-metadata/supported-locales (clojure.spec.alpha/and :portkey.aws.lex-models/locale-list))
(clojure.spec.alpha/def :portkey.aws.lex-models/builtin-intent-metadata (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.builtin-intent-metadata/signature :portkey.aws.lex-models.builtin-intent-metadata/supportedLocales]))

(clojure.spec.alpha/def :portkey.aws.lex-models/intent-utterance-list (clojure.spec.alpha/coll-of :portkey.aws.lex-models/utterance :max-count 1500))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-builtin-intent-response/signature (clojure.spec.alpha/and :portkey.aws.lex-models/builtin-intent-signature))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-builtin-intent-response/supported-locales (clojure.spec.alpha/and :portkey.aws.lex-models/locale-list))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-builtin-intent-response/slots (clojure.spec.alpha/and :portkey.aws.lex-models/builtin-intent-slot-list))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-builtin-intent-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.get-builtin-intent-response/signature :portkey.aws.lex-models.get-builtin-intent-response/supportedLocales :portkey.aws.lex-models.get-builtin-intent-response/slots]))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-slot-type-request/name (clojure.spec.alpha/and :portkey.aws.lex-models/slot-type-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-slot-type-request/version (clojure.spec.alpha/and :portkey.aws.lex-models/version))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-slot-type-request (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.get-slot-type-request/name :portkey.aws.lex-models.get-slot-type-request/version] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lex-models.enumeration-value/value (clojure.spec.alpha/and :portkey.aws.lex-models/value))
(clojure.spec.alpha/def :portkey.aws.lex-models/enumeration-value (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.enumeration-value/value] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lex-models/alias-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__30837__auto__] (clojure.core/<= 1 (clojure.core/count s__30837__auto__))) (clojure.core/fn [s__30838__auto__] (clojure.core/< (clojure.core/count s__30838__auto__) 100)) (clojure.core/fn [s__30839__auto__] (clojure.core/re-matches #"^[a-zA-Z]+((_[a-zA-Z]+)*|([a-zA-Z]+_)*|_)" s__30839__auto__))))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-alias-response/name (clojure.spec.alpha/and :portkey.aws.lex-models/alias-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-alias-response/description (clojure.spec.alpha/and :portkey.aws.lex-models/description))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-alias-response/bot-version (clojure.spec.alpha/and :portkey.aws.lex-models/version))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-alias-response/bot-name (clojure.spec.alpha/and :portkey.aws.lex-models/bot-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-alias-response/last-updated-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-alias-response/created-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-alias-response/checksum (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-bot-alias-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.get-bot-alias-response/name :portkey.aws.lex-models.get-bot-alias-response/description :portkey.aws.lex-models.get-bot-alias-response/botVersion :portkey.aws.lex-models.get-bot-alias-response/botName :portkey.aws.lex-models.get-bot-alias-response/lastUpdatedDate :portkey.aws.lex-models.get-bot-alias-response/createdDate :portkey.aws.lex-models.get-bot-alias-response/checksum]))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-slot-type-response/name (clojure.spec.alpha/and :portkey.aws.lex-models/slot-type-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-slot-type-response/description (clojure.spec.alpha/and :portkey.aws.lex-models/description))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-slot-type-response/enumeration-values (clojure.spec.alpha/and :portkey.aws.lex-models/enumeration-values))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-slot-type-response/last-updated-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-slot-type-response/created-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-slot-type-response/version (clojure.spec.alpha/and :portkey.aws.lex-models/version))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-slot-type-response/checksum (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-slot-type-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.get-slot-type-response/name :portkey.aws.lex-models.get-slot-type-response/description :portkey.aws.lex-models.get-slot-type-response/enumerationValues :portkey.aws.lex-models.get-slot-type-response/lastUpdatedDate :portkey.aws.lex-models.get-slot-type-response/createdDate :portkey.aws.lex-models.get-slot-type-response/version :portkey.aws.lex-models.get-slot-type-response/checksum]))

(clojure.spec.alpha/def :portkey.aws.lex-models/name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__30837__auto__] (clojure.core/<= 1 (clojure.core/count s__30837__auto__))) (clojure.core/fn [s__30838__auto__] (clojure.core/< (clojure.core/count s__30838__auto__) 64)) (clojure.core/fn [s__30839__auto__] (clojure.core/re-matches #"[a-zA-Z]+" s__30839__auto__))))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-versions-response/bots (clojure.spec.alpha/and :portkey.aws.lex-models/bot-metadata-list))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-versions-response/next-token (clojure.spec.alpha/and :portkey.aws.lex-models/next-token))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-bot-versions-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.get-bot-versions-response/bots :portkey.aws.lex-models.get-bot-versions-response/nextToken]))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-request/name (clojure.spec.alpha/and :portkey.aws.lex-models/bot-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-request/version-or-alias (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-bot-request (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.get-bot-request/name :portkey.aws.lex-models.get-bot-request/versionOrAlias] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-aliases-request/bot-name (clojure.spec.alpha/and :portkey.aws.lex-models/bot-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-aliases-request/next-token (clojure.spec.alpha/and :portkey.aws.lex-models/next-token))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-aliases-request/max-results (clojure.spec.alpha/and :portkey.aws.lex-models/max-results))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-aliases-request/name-contains (clojure.spec.alpha/and :portkey.aws.lex-models/alias-name))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-bot-aliases-request (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.get-bot-aliases-request/botName] :opt-un [:portkey.aws.lex-models.get-bot-aliases-request/nextToken :portkey.aws.lex-models.get-bot-aliases-request/maxResults :portkey.aws.lex-models.get-bot-aliases-request/nameContains]))

(clojure.spec.alpha/def :portkey.aws.lex-models/bot-metadata-list (clojure.spec.alpha/coll-of :portkey.aws.lex-models/bot-metadata :max-count nil))

(clojure.spec.alpha/def :portkey.aws.lex-models.bot-channel-association/name (clojure.spec.alpha/and :portkey.aws.lex-models/bot-channel-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.bot-channel-association/description (clojure.spec.alpha/and :portkey.aws.lex-models/description))
(clojure.spec.alpha/def :portkey.aws.lex-models.bot-channel-association/bot-alias (clojure.spec.alpha/and :portkey.aws.lex-models/alias-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.bot-channel-association/bot-name (clojure.spec.alpha/and :portkey.aws.lex-models/bot-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.bot-channel-association/created-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.bot-channel-association/type (clojure.spec.alpha/and :portkey.aws.lex-models/channel-type))
(clojure.spec.alpha/def :portkey.aws.lex-models.bot-channel-association/bot-configuration (clojure.spec.alpha/and :portkey.aws.lex-models/channel-configuration-map))
(clojure.spec.alpha/def :portkey.aws.lex-models/bot-channel-association (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.bot-channel-association/name :portkey.aws.lex-models.bot-channel-association/description :portkey.aws.lex-models.bot-channel-association/botAlias :portkey.aws.lex-models.bot-channel-association/botName :portkey.aws.lex-models.bot-channel-association/createdDate :portkey.aws.lex-models.bot-channel-association/type :portkey.aws.lex-models.bot-channel-association/botConfiguration]))

(clojure.spec.alpha/def :portkey.aws.lex-models/bot-channel-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__30837__auto__] (clojure.core/<= 1 (clojure.core/count s__30837__auto__))) (clojure.core/fn [s__30838__auto__] (clojure.core/< (clojure.core/count s__30838__auto__) 100)) (clojure.core/fn [s__30839__auto__] (clojure.core/re-matches #"^[a-zA-Z]+((_[a-zA-Z]+)*|([a-zA-Z]+_)*|_)" s__30839__auto__))))

(clojure.spec.alpha/def :portkey.aws.lex-models.builtin-slot-type-metadata/signature (clojure.spec.alpha/and :portkey.aws.lex-models/builtin-slot-type-signature))
(clojure.spec.alpha/def :portkey.aws.lex-models.builtin-slot-type-metadata/supported-locales (clojure.spec.alpha/and :portkey.aws.lex-models/locale-list))
(clojure.spec.alpha/def :portkey.aws.lex-models/builtin-slot-type-metadata (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.builtin-slot-type-metadata/signature :portkey.aws.lex-models.builtin-slot-type-metadata/supportedLocales]))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-alias-request/name (clojure.spec.alpha/and :portkey.aws.lex-models/alias-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-bot-alias-request/bot-name (clojure.spec.alpha/and :portkey.aws.lex-models/bot-name))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-bot-alias-request (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.get-bot-alias-request/name :portkey.aws.lex-models.get-bot-alias-request/botName] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lex-models/process-behavior (clojure.spec.alpha/conformer (clojure.core/let [m__30835__auto__ {"SAVE" "SAVE", :save "SAVE", "BUILD" "BUILD", :build "BUILD"}] (clojure.core/fn [s__30836__auto__] (m__30835__auto__ s__30836__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.awsgen/dashed)))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-builtin-intents-response/intents (clojure.spec.alpha/and :portkey.aws.lex-models/builtin-intent-metadata-list))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-builtin-intents-response/next-token (clojure.spec.alpha/and :portkey.aws.lex-models/next-token))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-builtin-intents-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.get-builtin-intents-response/intents :portkey.aws.lex-models.get-builtin-intents-response/nextToken]))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-slot-types-response/slot-types (clojure.spec.alpha/and :portkey.aws.lex-models/slot-type-metadata-list))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-slot-types-response/next-token (clojure.spec.alpha/and :portkey.aws.lex-models/next-token))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-slot-types-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.get-slot-types-response/slotTypes :portkey.aws.lex-models.get-slot-types-response/nextToken]))

(clojure.spec.alpha/def :portkey.aws.lex-models/lists-of-utterances (clojure.spec.alpha/coll-of :portkey.aws.lex-models/utterance-list :max-count nil))

(clojure.spec.alpha/def :portkey.aws.lex-models.intent/intent-name (clojure.spec.alpha/and :portkey.aws.lex-models/intent-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.intent/intent-version (clojure.spec.alpha/and :portkey.aws.lex-models/version))
(clojure.spec.alpha/def :portkey.aws.lex-models/intent (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.intent/intentName :portkey.aws.lex-models.intent/intentVersion] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lex-models.create-intent-version-response/follow-up-prompt (clojure.spec.alpha/and :portkey.aws.lex-models/follow-up-prompt))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-intent-version-response/fulfillment-activity (clojure.spec.alpha/and :portkey.aws.lex-models/fulfillment-activity))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-intent-version-response/slots (clojure.spec.alpha/and :portkey.aws.lex-models/slot-list))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-intent-version-response/parent-intent-signature (clojure.spec.alpha/and :portkey.aws.lex-models/builtin-intent-signature))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-intent-version-response/confirmation-prompt (clojure.spec.alpha/and :portkey.aws.lex-models/prompt))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-intent-version-response/created-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-intent-version-response/name (clojure.spec.alpha/and :portkey.aws.lex-models/intent-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-intent-version-response/rejection-statement (clojure.spec.alpha/and :portkey.aws.lex-models/statement))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-intent-version-response/last-updated-date (clojure.spec.alpha/and :portkey.aws.lex-models/timestamp))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-intent-version-response/dialog-code-hook (clojure.spec.alpha/and :portkey.aws.lex-models/code-hook))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-intent-version-response/conclusion-statement (clojure.spec.alpha/and :portkey.aws.lex-models/statement))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-intent-version-response/sample-utterances (clojure.spec.alpha/and :portkey.aws.lex-models/intent-utterance-list))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-intent-version-response/version (clojure.spec.alpha/and :portkey.aws.lex-models/version))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-intent-version-response/checksum (clojure.spec.alpha/and :portkey.aws.lex-models/string))
(clojure.spec.alpha/def :portkey.aws.lex-models.create-intent-version-response/description (clojure.spec.alpha/and :portkey.aws.lex-models/description))
(clojure.spec.alpha/def :portkey.aws.lex-models/create-intent-version-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.lex-models.create-intent-version-response/followUpPrompt :portkey.aws.lex-models.create-intent-version-response/fulfillmentActivity :portkey.aws.lex-models.create-intent-version-response/slots :portkey.aws.lex-models.create-intent-version-response/parentIntentSignature :portkey.aws.lex-models.create-intent-version-response/confirmationPrompt :portkey.aws.lex-models.create-intent-version-response/createdDate :portkey.aws.lex-models.create-intent-version-response/name :portkey.aws.lex-models.create-intent-version-response/rejectionStatement :portkey.aws.lex-models.create-intent-version-response/lastUpdatedDate :portkey.aws.lex-models.create-intent-version-response/dialogCodeHook :portkey.aws.lex-models.create-intent-version-response/conclusionStatement :portkey.aws.lex-models.create-intent-version-response/sampleUtterances :portkey.aws.lex-models.create-intent-version-response/version :portkey.aws.lex-models.create-intent-version-response/checksum :portkey.aws.lex-models.create-intent-version-response/description]))

(clojure.spec.alpha/def :portkey.aws.lex-models/channel-type (clojure.spec.alpha/conformer (clojure.core/let [m__30835__auto__ {"Facebook" "Facebook", :facebook "Facebook", "Slack" "Slack", :slack "Slack", "Twilio-Sms" "Twilio-Sms", :twilio-sms "Twilio-Sms"}] (clojure.core/fn [s__30836__auto__] (m__30835__auto__ s__30836__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.awsgen/dashed)))

(clojure.spec.alpha/def :portkey.aws.lex-models.get-utterances-view-request/bot-name (clojure.spec.alpha/and :portkey.aws.lex-models/bot-name))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-utterances-view-request/bot-versions (clojure.spec.alpha/and :portkey.aws.lex-models/bot-versions))
(clojure.spec.alpha/def :portkey.aws.lex-models.get-utterances-view-request/status-type (clojure.spec.alpha/and :portkey.aws.lex-models/status-type))
(clojure.spec.alpha/def :portkey.aws.lex-models/get-utterances-view-request (portkey.awsgen/json-keys :req-un [:portkey.aws.lex-models.get-utterances-view-request/botName :portkey.aws.lex-models.get-utterances-view-request/botVersions :portkey.aws.lex-models.get-utterances-view-request/statusType] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.lex-models/boolean clojure.core/boolean?)

(clojure.core/defn delete-bot-channel-association ([input__33752__auto__] (delete-bot-channel-association input__33752__auto__ portkey.aws/*http-client*)) ([input34120 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "DELETE", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/bots/{botName}/aliases/{aliasName}/channels/{name}", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/DeleteBotChannelAssociationRequest input34120)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri ["name" "name"] ["botName" "botName"] ["aliasName" "botAlias"]) (portkey.awsgen/params-to-querystring) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "DELETE", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/bots/{botName}/aliases/{aliasName}/channels/{name}", :body body__33756__auto__} (clojure.core/fn [response34119] (clojure.core/let [errors__33757__auto__ {"NotFoundException" :portkey.aws.lex-models/not-found-exception, "ConflictException" :portkey.aws.lex-models/conflict-exception, "LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception}] (if (clojure.core/= 204 (:status response34119)) true (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34119 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34119)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34119}))))))))))

(clojure.core/defn get-builtin-slot-types ([input__33752__auto__] (get-builtin-slot-types input__33752__auto__ portkey.aws/*http-client*)) ([input34122 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/builtins/slottypes/", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/GetBuiltinSlotTypesRequest input34122)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri) (portkey.awsgen/params-to-querystring ["locale" "locale"] ["signatureContains" "signatureContains"] ["nextToken" "nextToken"] ["maxResults" "maxResults"]) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/builtins/slottypes/", :body body__33756__auto__} (clojure.core/fn [response34121] (clojure.core/let [errors__33757__auto__ {"LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception}] (if (clojure.core/= 200 (:status response34121)) (clojure.spec.alpha/unform :portkey.aws.lex-models/get-builtin-slot-types-response (:body response34121)) (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34121 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34121)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34121}))))))))))

(clojure.core/defn get-bot-channel-associations ([input__33752__auto__] (get-bot-channel-associations input__33752__auto__ portkey.aws/*http-client*)) ([input34124 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/bots/{botName}/aliases/{aliasName}/channels/", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/GetBotChannelAssociationsRequest input34124)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri ["botName" "botName"] ["aliasName" "botAlias"]) (portkey.awsgen/params-to-querystring ["nextToken" "nextToken"] ["maxResults" "maxResults"] ["nameContains" "nameContains"]) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/bots/{botName}/aliases/{aliasName}/channels/", :body body__33756__auto__} (clojure.core/fn [response34123] (clojure.core/let [errors__33757__auto__ {"LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception}] (if (clojure.core/= 200 (:status response34123)) (clojure.spec.alpha/unform :portkey.aws.lex-models/get-bot-channel-associations-response (:body response34123)) (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34123 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34123)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34123}))))))))))

(clojure.core/defn create-slot-type-version ([input__33752__auto__] (create-slot-type-version input__33752__auto__ portkey.aws/*http-client*)) ([input34126 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "POST", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/slottypes/{name}/versions", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/CreateSlotTypeVersionRequest input34126)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri ["name" "name"]) (portkey.awsgen/params-to-querystring) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "POST", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/slottypes/{name}/versions", :body body__33756__auto__} (clojure.core/fn [response34125] (clojure.core/let [errors__33757__auto__ {"NotFoundException" :portkey.aws.lex-models/not-found-exception, "ConflictException" :portkey.aws.lex-models/conflict-exception, "LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception, "PreconditionFailedException" :portkey.aws.lex-models/precondition-failed-exception}] (if (clojure.core/= 201 (:status response34125)) (clojure.spec.alpha/unform :portkey.aws.lex-models/create-slot-type-version-response (:body response34125)) (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34125 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34125)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34125}))))))))))

(clojure.core/defn get-slot-type ([input__33752__auto__] (get-slot-type input__33752__auto__ portkey.aws/*http-client*)) ([input34128 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/slottypes/{name}/versions/{version}", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/GetSlotTypeRequest input34128)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri ["name" "name"] ["version" "version"]) (portkey.awsgen/params-to-querystring) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/slottypes/{name}/versions/{version}", :body body__33756__auto__} (clojure.core/fn [response34127] (clojure.core/let [errors__33757__auto__ {"NotFoundException" :portkey.aws.lex-models/not-found-exception, "LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception}] (if (clojure.core/= 200 (:status response34127)) (clojure.spec.alpha/unform :portkey.aws.lex-models/get-slot-type-response (:body response34127)) (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34127 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34127)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34127}))))))))))

(clojure.core/defn get-intent-versions ([input__33752__auto__] (get-intent-versions input__33752__auto__ portkey.aws/*http-client*)) ([input34130 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/intents/{name}/versions/", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/GetIntentVersionsRequest input34130)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri ["name" "name"]) (portkey.awsgen/params-to-querystring ["nextToken" "nextToken"] ["maxResults" "maxResults"]) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/intents/{name}/versions/", :body body__33756__auto__} (clojure.core/fn [response34129] (clojure.core/let [errors__33757__auto__ {"NotFoundException" :portkey.aws.lex-models/not-found-exception, "LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception}] (if (clojure.core/= 200 (:status response34129)) (clojure.spec.alpha/unform :portkey.aws.lex-models/get-intent-versions-response (:body response34129)) (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34129 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34129)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34129}))))))))))

(clojure.core/defn get-utterances-view ([input__33752__auto__] (get-utterances-view input__33752__auto__ portkey.aws/*http-client*)) ([input34132 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/bots/{botname}/utterances?view=aggregation", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/GetUtterancesViewRequest input34132)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri ["botname" "botName"]) (portkey.awsgen/params-to-querystring ["bot_versions" "botVersions"] ["status_type" "statusType"]) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/bots/{botname}/utterances?view=aggregation", :body body__33756__auto__} (clojure.core/fn [response34131] (clojure.core/let [errors__33757__auto__ {"LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception}] (if (clojure.core/= 200 (:status response34131)) (clojure.spec.alpha/unform :portkey.aws.lex-models/get-utterances-view-response (:body response34131)) (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34131 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34131)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34131}))))))))))

(clojure.core/defn delete-intent-version ([input__33752__auto__] (delete-intent-version input__33752__auto__ portkey.aws/*http-client*)) ([input34134 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "DELETE", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/intents/{name}/versions/{version}", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/DeleteIntentVersionRequest input34134)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri ["name" "name"] ["version" "version"]) (portkey.awsgen/params-to-querystring) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "DELETE", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/intents/{name}/versions/{version}", :body body__33756__auto__} (clojure.core/fn [response34133] (clojure.core/let [errors__33757__auto__ {"NotFoundException" :portkey.aws.lex-models/not-found-exception, "ConflictException" :portkey.aws.lex-models/conflict-exception, "LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception, "ResourceInUseException" :portkey.aws.lex-models/resource-in-use-exception}] (if (clojure.core/= 204 (:status response34133)) true (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34133 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34133)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34133}))))))))))

(clojure.core/defn get-builtin-intents ([input__33752__auto__] (get-builtin-intents input__33752__auto__ portkey.aws/*http-client*)) ([input34136 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/builtins/intents/", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/GetBuiltinIntentsRequest input34136)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri) (portkey.awsgen/params-to-querystring ["locale" "locale"] ["signatureContains" "signatureContains"] ["nextToken" "nextToken"] ["maxResults" "maxResults"]) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/builtins/intents/", :body body__33756__auto__} (clojure.core/fn [response34135] (clojure.core/let [errors__33757__auto__ {"LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception}] (if (clojure.core/= 200 (:status response34135)) (clojure.spec.alpha/unform :portkey.aws.lex-models/get-builtin-intents-response (:body response34135)) (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34135 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34135)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34135}))))))))))

(clojure.core/defn get-slot-types ([input__33752__auto__] (get-slot-types input__33752__auto__ portkey.aws/*http-client*)) ([input34138 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/slottypes/", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/GetSlotTypesRequest input34138)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri) (portkey.awsgen/params-to-querystring ["nextToken" "nextToken"] ["maxResults" "maxResults"] ["nameContains" "nameContains"]) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/slottypes/", :body body__33756__auto__} (clojure.core/fn [response34137] (clojure.core/let [errors__33757__auto__ {"NotFoundException" :portkey.aws.lex-models/not-found-exception, "LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception}] (if (clojure.core/= 200 (:status response34137)) (clojure.spec.alpha/unform :portkey.aws.lex-models/get-slot-types-response (:body response34137)) (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34137 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34137)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34137}))))))))))

(clojure.core/defn get-bot-alias ([input__33752__auto__] (get-bot-alias input__33752__auto__ portkey.aws/*http-client*)) ([input34140 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/bots/{botName}/aliases/{name}", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/GetBotAliasRequest input34140)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri ["name" "name"] ["botName" "botName"]) (portkey.awsgen/params-to-querystring) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/bots/{botName}/aliases/{name}", :body body__33756__auto__} (clojure.core/fn [response34139] (clojure.core/let [errors__33757__auto__ {"NotFoundException" :portkey.aws.lex-models/not-found-exception, "LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception}] (if (clojure.core/= 200 (:status response34139)) (clojure.spec.alpha/unform :portkey.aws.lex-models/get-bot-alias-response (:body response34139)) (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34139 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34139)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34139}))))))))))

(clojure.core/defn get-builtin-intent ([input__33752__auto__] (get-builtin-intent input__33752__auto__ portkey.aws/*http-client*)) ([input34142 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/builtins/intents/{signature}", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/GetBuiltinIntentRequest input34142)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri ["signature" "signature"]) (portkey.awsgen/params-to-querystring) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/builtins/intents/{signature}", :body body__33756__auto__} (clojure.core/fn [response34141] (clojure.core/let [errors__33757__auto__ {"NotFoundException" :portkey.aws.lex-models/not-found-exception, "LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception}] (if (clojure.core/= 200 (:status response34141)) (clojure.spec.alpha/unform :portkey.aws.lex-models/get-builtin-intent-response (:body response34141)) (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34141 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34141)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34141}))))))))))

(clojure.core/defn delete-slot-type ([input__33752__auto__] (delete-slot-type input__33752__auto__ portkey.aws/*http-client*)) ([input34144 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "DELETE", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/slottypes/{name}", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/DeleteSlotTypeRequest input34144)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri ["name" "name"]) (portkey.awsgen/params-to-querystring) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "DELETE", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/slottypes/{name}", :body body__33756__auto__} (clojure.core/fn [response34143] (clojure.core/let [errors__33757__auto__ {"NotFoundException" :portkey.aws.lex-models/not-found-exception, "ConflictException" :portkey.aws.lex-models/conflict-exception, "LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception, "ResourceInUseException" :portkey.aws.lex-models/resource-in-use-exception}] (if (clojure.core/= 204 (:status response34143)) true (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34143 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34143)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34143}))))))))))

(clojure.core/defn create-bot-version ([input__33752__auto__] (create-bot-version input__33752__auto__ portkey.aws/*http-client*)) ([input34146 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "POST", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/bots/{name}/versions", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/CreateBotVersionRequest input34146)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri ["name" "name"]) (portkey.awsgen/params-to-querystring) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "POST", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/bots/{name}/versions", :body body__33756__auto__} (clojure.core/fn [response34145] (clojure.core/let [errors__33757__auto__ {"NotFoundException" :portkey.aws.lex-models/not-found-exception, "ConflictException" :portkey.aws.lex-models/conflict-exception, "LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception, "PreconditionFailedException" :portkey.aws.lex-models/precondition-failed-exception}] (if (clojure.core/= 201 (:status response34145)) (clojure.spec.alpha/unform :portkey.aws.lex-models/create-bot-version-response (:body response34145)) (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34145 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34145)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34145}))))))))))

(clojure.core/defn put-intent ([input__33752__auto__] (put-intent input__33752__auto__ portkey.aws/*http-client*)) ([input34148 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "PUT", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/intents/{name}/versions/$LATEST", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/PutIntentRequest input34148)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri ["name" "name"]) (portkey.awsgen/params-to-querystring) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "PUT", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/intents/{name}/versions/$LATEST", :body body__33756__auto__} (clojure.core/fn [response34147] (clojure.core/let [errors__33757__auto__ {"ConflictException" :portkey.aws.lex-models/conflict-exception, "LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception, "PreconditionFailedException" :portkey.aws.lex-models/precondition-failed-exception}] (if (clojure.core/= 200 (:status response34147)) (clojure.spec.alpha/unform :portkey.aws.lex-models/put-intent-response (:body response34147)) (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34147 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34147)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34147}))))))))))

(clojure.core/defn delete-intent ([input__33752__auto__] (delete-intent input__33752__auto__ portkey.aws/*http-client*)) ([input34150 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "DELETE", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/intents/{name}", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/DeleteIntentRequest input34150)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri ["name" "name"]) (portkey.awsgen/params-to-querystring) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "DELETE", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/intents/{name}", :body body__33756__auto__} (clojure.core/fn [response34149] (clojure.core/let [errors__33757__auto__ {"NotFoundException" :portkey.aws.lex-models/not-found-exception, "ConflictException" :portkey.aws.lex-models/conflict-exception, "LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception, "ResourceInUseException" :portkey.aws.lex-models/resource-in-use-exception}] (if (clojure.core/= 204 (:status response34149)) true (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34149 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34149)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34149}))))))))))

(clojure.core/defn get-intents ([input__33752__auto__] (get-intents input__33752__auto__ portkey.aws/*http-client*)) ([input34152 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/intents/", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/GetIntentsRequest input34152)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri) (portkey.awsgen/params-to-querystring ["nextToken" "nextToken"] ["maxResults" "maxResults"] ["nameContains" "nameContains"]) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/intents/", :body body__33756__auto__} (clojure.core/fn [response34151] (clojure.core/let [errors__33757__auto__ {"NotFoundException" :portkey.aws.lex-models/not-found-exception, "LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception}] (if (clojure.core/= 200 (:status response34151)) (clojure.spec.alpha/unform :portkey.aws.lex-models/get-intents-response (:body response34151)) (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34151 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34151)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34151}))))))))))

(clojure.core/defn delete-utterances ([input__33752__auto__] (delete-utterances input__33752__auto__ portkey.aws/*http-client*)) ([input34154 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "DELETE", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/bots/{botName}/utterances/{userId}", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/DeleteUtterancesRequest input34154)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri ["botName" "botName"] ["userId" "userId"]) (portkey.awsgen/params-to-querystring) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "DELETE", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/bots/{botName}/utterances/{userId}", :body body__33756__auto__} (clojure.core/fn [response34153] (clojure.core/let [errors__33757__auto__ {"NotFoundException" :portkey.aws.lex-models/not-found-exception, "LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception}] (if (clojure.core/= 204 (:status response34153)) true (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34153 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34153)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34153}))))))))))

(clojure.core/defn get-intent ([input__33752__auto__] (get-intent input__33752__auto__ portkey.aws/*http-client*)) ([input34156 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/intents/{name}/versions/{version}", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/GetIntentRequest input34156)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri ["name" "name"] ["version" "version"]) (portkey.awsgen/params-to-querystring) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/intents/{name}/versions/{version}", :body body__33756__auto__} (clojure.core/fn [response34155] (clojure.core/let [errors__33757__auto__ {"NotFoundException" :portkey.aws.lex-models/not-found-exception, "LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception}] (if (clojure.core/= 200 (:status response34155)) (clojure.spec.alpha/unform :portkey.aws.lex-models/get-intent-response (:body response34155)) (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34155 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34155)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34155}))))))))))

(clojure.core/defn create-intent-version ([input__33752__auto__] (create-intent-version input__33752__auto__ portkey.aws/*http-client*)) ([input34158 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "POST", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/intents/{name}/versions", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/CreateIntentVersionRequest input34158)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri ["name" "name"]) (portkey.awsgen/params-to-querystring) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "POST", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/intents/{name}/versions", :body body__33756__auto__} (clojure.core/fn [response34157] (clojure.core/let [errors__33757__auto__ {"NotFoundException" :portkey.aws.lex-models/not-found-exception, "ConflictException" :portkey.aws.lex-models/conflict-exception, "LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception, "PreconditionFailedException" :portkey.aws.lex-models/precondition-failed-exception}] (if (clojure.core/= 201 (:status response34157)) (clojure.spec.alpha/unform :portkey.aws.lex-models/create-intent-version-response (:body response34157)) (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34157 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34157)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34157}))))))))))

(clojure.core/defn get-bot-channel-association ([input__33752__auto__] (get-bot-channel-association input__33752__auto__ portkey.aws/*http-client*)) ([input34160 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/bots/{botName}/aliases/{aliasName}/channels/{name}", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/GetBotChannelAssociationRequest input34160)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri ["name" "name"] ["botName" "botName"] ["aliasName" "botAlias"]) (portkey.awsgen/params-to-querystring) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/bots/{botName}/aliases/{aliasName}/channels/{name}", :body body__33756__auto__} (clojure.core/fn [response34159] (clojure.core/let [errors__33757__auto__ {"NotFoundException" :portkey.aws.lex-models/not-found-exception, "LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception}] (if (clojure.core/= 200 (:status response34159)) (clojure.spec.alpha/unform :portkey.aws.lex-models/get-bot-channel-association-response (:body response34159)) (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34159 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34159)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34159}))))))))))

(clojure.core/defn put-slot-type ([input__33752__auto__] (put-slot-type input__33752__auto__ portkey.aws/*http-client*)) ([input34162 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "PUT", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/slottypes/{name}/versions/$LATEST", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/PutSlotTypeRequest input34162)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri ["name" "name"]) (portkey.awsgen/params-to-querystring) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "PUT", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/slottypes/{name}/versions/$LATEST", :body body__33756__auto__} (clojure.core/fn [response34161] (clojure.core/let [errors__33757__auto__ {"ConflictException" :portkey.aws.lex-models/conflict-exception, "LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception, "PreconditionFailedException" :portkey.aws.lex-models/precondition-failed-exception}] (if (clojure.core/= 200 (:status response34161)) (clojure.spec.alpha/unform :portkey.aws.lex-models/put-slot-type-response (:body response34161)) (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34161 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34161)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34161}))))))))))

(clojure.core/defn get-slot-type-versions ([input__33752__auto__] (get-slot-type-versions input__33752__auto__ portkey.aws/*http-client*)) ([input34164 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/slottypes/{name}/versions/", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/GetSlotTypeVersionsRequest input34164)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri ["name" "name"]) (portkey.awsgen/params-to-querystring ["nextToken" "nextToken"] ["maxResults" "maxResults"]) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/slottypes/{name}/versions/", :body body__33756__auto__} (clojure.core/fn [response34163] (clojure.core/let [errors__33757__auto__ {"NotFoundException" :portkey.aws.lex-models/not-found-exception, "LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception}] (if (clojure.core/= 200 (:status response34163)) (clojure.spec.alpha/unform :portkey.aws.lex-models/get-slot-type-versions-response (:body response34163)) (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34163 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34163)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34163}))))))))))

(clojure.core/defn delete-bot-version ([input__33752__auto__] (delete-bot-version input__33752__auto__ portkey.aws/*http-client*)) ([input34166 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "DELETE", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/bots/{name}/versions/{version}", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/DeleteBotVersionRequest input34166)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri ["name" "name"] ["version" "version"]) (portkey.awsgen/params-to-querystring) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "DELETE", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/bots/{name}/versions/{version}", :body body__33756__auto__} (clojure.core/fn [response34165] (clojure.core/let [errors__33757__auto__ {"NotFoundException" :portkey.aws.lex-models/not-found-exception, "ConflictException" :portkey.aws.lex-models/conflict-exception, "LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception, "ResourceInUseException" :portkey.aws.lex-models/resource-in-use-exception}] (if (clojure.core/= 204 (:status response34165)) true (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34165 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34165)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34165}))))))))))

(clojure.core/defn get-bot-aliases ([input__33752__auto__] (get-bot-aliases input__33752__auto__ portkey.aws/*http-client*)) ([input34168 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/bots/{botName}/aliases/", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/GetBotAliasesRequest input34168)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri ["botName" "botName"]) (portkey.awsgen/params-to-querystring ["nextToken" "nextToken"] ["maxResults" "maxResults"] ["nameContains" "nameContains"]) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/bots/{botName}/aliases/", :body body__33756__auto__} (clojure.core/fn [response34167] (clojure.core/let [errors__33757__auto__ {"LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception}] (if (clojure.core/= 200 (:status response34167)) (clojure.spec.alpha/unform :portkey.aws.lex-models/get-bot-aliases-response (:body response34167)) (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34167 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34167)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34167}))))))))))

(clojure.core/defn get-bot-versions ([input__33752__auto__] (get-bot-versions input__33752__auto__ portkey.aws/*http-client*)) ([input34170 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/bots/{name}/versions/", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/GetBotVersionsRequest input34170)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri ["name" "name"]) (portkey.awsgen/params-to-querystring ["nextToken" "nextToken"] ["maxResults" "maxResults"]) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/bots/{name}/versions/", :body body__33756__auto__} (clojure.core/fn [response34169] (clojure.core/let [errors__33757__auto__ {"NotFoundException" :portkey.aws.lex-models/not-found-exception, "LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception}] (if (clojure.core/= 200 (:status response34169)) (clojure.spec.alpha/unform :portkey.aws.lex-models/get-bot-versions-response (:body response34169)) (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34169 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34169)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34169}))))))))))

(clojure.core/defn put-bot-alias ([input__33752__auto__] (put-bot-alias input__33752__auto__ portkey.aws/*http-client*)) ([input34172 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "PUT", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/bots/{botName}/aliases/{name}", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/PutBotAliasRequest input34172)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri ["name" "name"] ["botName" "botName"]) (portkey.awsgen/params-to-querystring) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "PUT", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/bots/{botName}/aliases/{name}", :body body__33756__auto__} (clojure.core/fn [response34171] (clojure.core/let [errors__33757__auto__ {"ConflictException" :portkey.aws.lex-models/conflict-exception, "LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception, "PreconditionFailedException" :portkey.aws.lex-models/precondition-failed-exception}] (if (clojure.core/= 200 (:status response34171)) (clojure.spec.alpha/unform :portkey.aws.lex-models/put-bot-alias-response (:body response34171)) (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34171 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34171)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34171}))))))))))

(clojure.core/defn get-bots ([input__33752__auto__] (get-bots input__33752__auto__ portkey.aws/*http-client*)) ([input34174 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/bots/", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/GetBotsRequest input34174)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri) (portkey.awsgen/params-to-querystring ["nextToken" "nextToken"] ["maxResults" "maxResults"] ["nameContains" "nameContains"]) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/bots/", :body body__33756__auto__} (clojure.core/fn [response34173] (clojure.core/let [errors__33757__auto__ {"NotFoundException" :portkey.aws.lex-models/not-found-exception, "LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception}] (if (clojure.core/= 200 (:status response34173)) (clojure.spec.alpha/unform :portkey.aws.lex-models/get-bots-response (:body response34173)) (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34173 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34173)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34173}))))))))))

(clojure.core/defn get-bot ([input__33752__auto__] (get-bot input__33752__auto__ portkey.aws/*http-client*)) ([input34176 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/bots/{name}/versions/{versionoralias}", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/GetBotRequest input34176)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri ["name" "name"] ["versionoralias" "versionOrAlias"]) (portkey.awsgen/params-to-querystring) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "GET", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/bots/{name}/versions/{versionoralias}", :body body__33756__auto__} (clojure.core/fn [response34175] (clojure.core/let [errors__33757__auto__ {"NotFoundException" :portkey.aws.lex-models/not-found-exception, "LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception}] (if (clojure.core/= 200 (:status response34175)) (clojure.spec.alpha/unform :portkey.aws.lex-models/get-bot-response (:body response34175)) (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34175 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34175)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34175}))))))))))

(clojure.core/defn delete-slot-type-version ([input__33752__auto__] (delete-slot-type-version input__33752__auto__ portkey.aws/*http-client*)) ([input34178 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "DELETE", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/slottypes/{name}/version/{version}", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/DeleteSlotTypeVersionRequest input34178)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri ["name" "name"] ["version" "version"]) (portkey.awsgen/params-to-querystring) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "DELETE", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/slottypes/{name}/version/{version}", :body body__33756__auto__} (clojure.core/fn [response34177] (clojure.core/let [errors__33757__auto__ {"NotFoundException" :portkey.aws.lex-models/not-found-exception, "ConflictException" :portkey.aws.lex-models/conflict-exception, "LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception, "ResourceInUseException" :portkey.aws.lex-models/resource-in-use-exception}] (if (clojure.core/= 204 (:status response34177)) true (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34177 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34177)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34177}))))))))))

(clojure.core/defn delete-bot ([input__33752__auto__] (delete-bot input__33752__auto__ portkey.aws/*http-client*)) ([input34180 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "DELETE", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/bots/{name}", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/DeleteBotRequest input34180)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri ["name" "name"]) (portkey.awsgen/params-to-querystring) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "DELETE", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/bots/{name}", :body body__33756__auto__} (clojure.core/fn [response34179] (clojure.core/let [errors__33757__auto__ {"NotFoundException" :portkey.aws.lex-models/not-found-exception, "ConflictException" :portkey.aws.lex-models/conflict-exception, "LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception, "ResourceInUseException" :portkey.aws.lex-models/resource-in-use-exception}] (if (clojure.core/= 204 (:status response34179)) true (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34179 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34179)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34179}))))))))))

(clojure.core/defn put-bot ([input__33752__auto__] (put-bot input__33752__auto__ portkey.aws/*http-client*)) ([input34182 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "PUT", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/bots/{name}/versions/$LATEST", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/PutBotRequest input34182)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri ["name" "name"]) (portkey.awsgen/params-to-querystring) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "PUT", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/bots/{name}/versions/$LATEST", :body body__33756__auto__} (clojure.core/fn [response34181] (clojure.core/let [errors__33757__auto__ {"ConflictException" :portkey.aws.lex-models/conflict-exception, "LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception, "PreconditionFailedException" :portkey.aws.lex-models/precondition-failed-exception}] (if (clojure.core/= 200 (:status response34181)) (clojure.spec.alpha/unform :portkey.aws.lex-models/put-bot-response (:body response34181)) (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34181 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34181)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34181}))))))))))

(clojure.core/defn delete-bot-alias ([input__33752__auto__] (delete-bot-alias input__33752__auto__ portkey.aws/*http-client*)) ([input34184 http-client__33753__auto__] (clojure.core/let [req__33754__auto__ (clojure.core/-> {:method "DELETE", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/bots/{botName}/aliases/{name}", :body (clojure.spec.alpha/unform :portkey.aws.lex-models/DeleteBotAliasRequest input34184)} (portkey.awsgen/params-to-header) (portkey.awsgen/params-to-uri ["name" "name"] ["botName" "botName"]) (portkey.awsgen/params-to-querystring) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__33751__33755__auto__] (clojure.core/some-> p1__33751__33755__auto__ cheshire.core/generate-string))))] (http-client__33753__auto__ {:method "DELETE", :headers {"content-type" "application/json"}, :url "https://lambda.eu-central-1.amazonaws.com/bots/{botName}/aliases/{name}", :body body__33756__auto__} (clojure.core/fn [response34183] (clojure.core/let [errors__33757__auto__ {"NotFoundException" :portkey.aws.lex-models/not-found-exception, "ConflictException" :portkey.aws.lex-models/conflict-exception, "LimitExceededException" :portkey.aws.lex-models/limit-exceeded-exception, "InternalFailureException" :portkey.aws.lex-models/internal-failure-exception, "BadRequestException" :portkey.aws.lex-models/bad-request-exception, "ResourceInUseException" :portkey.aws.lex-models/resource-in-use-exception}] (if (clojure.core/= 204 (:status response34183)) true (clojure.core/if-some [[type__33758__auto__ spec__33759__auto__] (clojure.core/find errors__33757__auto__ (clojure.core/get-in response34183 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__33760__auto__ (clojure.spec.alpha/unform spec__33759__auto__ (cheshire.core/parse-string (:body response34183)))] (throw (clojure.core/ex-info (clojure.core/str type__33758__auto__ ": " (:message m__33760__auto__)) m__33760__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response34183}))))))))))
