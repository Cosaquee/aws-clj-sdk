(ns portkey.aws.iot (:require [portkey.aws]))

(def
 endpoints
 '{"ap-northeast-1"
   {:credential-scope
    {:service "execute-api", :region "ap-northeast-1"},
    :ssl-common-name "iot.ap-northeast-1.amazonaws.com",
    :endpoint "https://iot.ap-northeast-1.amazonaws.com"},
   "eu-west-1"
   {:credential-scope {:service "execute-api", :region "eu-west-1"},
    :ssl-common-name "iot.eu-west-1.amazonaws.com",
    :endpoint "https://iot.eu-west-1.amazonaws.com"},
   "us-east-2"
   {:credential-scope {:service "execute-api", :region "us-east-2"},
    :ssl-common-name "iot.us-east-2.amazonaws.com",
    :endpoint "https://iot.us-east-2.amazonaws.com"},
   "ap-southeast-2"
   {:credential-scope
    {:service "execute-api", :region "ap-southeast-2"},
    :ssl-common-name "iot.ap-southeast-2.amazonaws.com",
    :endpoint "https://iot.ap-southeast-2.amazonaws.com"},
   "cn-north-1"
   {:credential-scope {:service "execute-api", :region "cn-north-1"},
    :ssl-common-name "iot.cn-north-1.amazonaws.com.cn",
    :endpoint "https://iot.cn-north-1.amazonaws.com.cn"},
   "ap-southeast-1"
   {:credential-scope
    {:service "execute-api", :region "ap-southeast-1"},
    :ssl-common-name "iot.ap-southeast-1.amazonaws.com",
    :endpoint "https://iot.ap-southeast-1.amazonaws.com"},
   "ap-northeast-2"
   {:credential-scope
    {:service "execute-api", :region "ap-northeast-2"},
    :ssl-common-name "iot.ap-northeast-2.amazonaws.com",
    :endpoint "https://iot.ap-northeast-2.amazonaws.com"},
   "eu-central-1"
   {:credential-scope {:service "execute-api", :region "eu-central-1"},
    :ssl-common-name "iot.eu-central-1.amazonaws.com",
    :endpoint "https://iot.eu-central-1.amazonaws.com"},
   "eu-west-2"
   {:credential-scope {:service "execute-api", :region "eu-west-2"},
    :ssl-common-name "iot.eu-west-2.amazonaws.com",
    :endpoint "https://iot.eu-west-2.amazonaws.com"},
   "us-west-2"
   {:credential-scope {:service "execute-api", :region "us-west-2"},
    :ssl-common-name "iot.us-west-2.amazonaws.com",
    :endpoint "https://iot.us-west-2.amazonaws.com"},
   "us-east-1"
   {:credential-scope {:service "execute-api", :region "us-east-1"},
    :ssl-common-name "iot.us-east-1.amazonaws.com",
    :endpoint "https://iot.us-east-1.amazonaws.com"}})

(clojure.spec.alpha/def :portkey.aws.iot.accept-certificate-transfer-request/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.accept-certificate-transfer-request/set-as-active (clojure.spec.alpha/and :portkey.aws.iot/set-as-active))
(clojure.spec.alpha/def :portkey.aws.iot/accept-certificate-transfer-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.accept-certificate-transfer-request/certificateId] :opt-un [:portkey.aws.iot.accept-certificate-transfer-request/setAsActive]))

(clojure.spec.alpha/def :portkey.aws.iot/registry-max-results (clojure.spec.alpha/and clojure.core/int? (fn* [p1__56642__56643__auto__] (clojure.core/<= 1 p1__56642__56643__auto__)) (fn* [p1__56644__56645__auto__] (clojure.core/<= p1__56644__56645__auto__ 250))))

(clojure.spec.alpha/def :portkey.aws.iot.list-policy-versions-response/policy-versions (clojure.spec.alpha/and :portkey.aws.iot/policy-versions))
(clojure.spec.alpha/def :portkey.aws.iot/list-policy-versions-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.list-policy-versions-response/policyVersions]))

(clojure.spec.alpha/def :portkey.aws.iot/auto-registration-status (clojure.spec.alpha/conformer (clojure.core/let [m__56599__auto__ {"ENABLE" "ENABLE", :enable "ENABLE", "DISABLE" "DISABLE", :disable "DISABLE"}] (clojure.core/fn [s__56600__auto__] (m__56599__auto__ s__56600__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.awsgen/dashed)))

(clojure.spec.alpha/def :portkey.aws.iot.deprecate-thing-type-request/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.deprecate-thing-type-request/undo-deprecate (clojure.spec.alpha/and :portkey.aws.iot/undo-deprecate))
(clojure.spec.alpha/def :portkey.aws.iot/deprecate-thing-type-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.deprecate-thing-type-request/thingTypeName] :opt-un [:portkey.aws.iot.deprecate-thing-type-request/undoDeprecate]))

(clojure.spec.alpha/def :portkey.aws.iot.unauthorized-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/unauthorized-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.unauthorized-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot/outgoing-certificates (clojure.spec.alpha/coll-of :portkey.aws.iot/outgoing-certificate :max-count nil))

(clojure.spec.alpha/def :portkey.aws.iot.detach-principal-policy-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.detach-principal-policy-request/principal (clojure.spec.alpha/and :portkey.aws.iot/principal))
(clojure.spec.alpha/def :portkey.aws.iot/detach-principal-policy-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.detach-principal-policy-request/policyName :portkey.aws.iot.detach-principal-policy-request/principal] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/range-key-field (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/thing-attribute-list (clojure.spec.alpha/coll-of :portkey.aws.iot/thing-attribute :max-count nil))

(clojure.spec.alpha/def :portkey.aws.iot.thing-type-properties/thing-type-description (clojure.spec.alpha/and :portkey.aws.iot/thing-type-description))
(clojure.spec.alpha/def :portkey.aws.iot.thing-type-properties/searchable-attributes (clojure.spec.alpha/and :portkey.aws.iot/searchable-attributes))
(clojure.spec.alpha/def :portkey.aws.iot/thing-type-properties (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.thing-type-properties/thingTypeDescription :portkey.aws.iot.thing-type-properties/searchableAttributes]))

(clojure.spec.alpha/def :portkey.aws.iot.register-certificate-request/certificate-pem (clojure.spec.alpha/and :portkey.aws.iot/certificate-pem))
(clojure.spec.alpha/def :portkey.aws.iot.register-certificate-request/ca-certificate-pem (clojure.spec.alpha/and :portkey.aws.iot/certificate-pem))
(clojure.spec.alpha/def :portkey.aws.iot.register-certificate-request/set-as-active (clojure.spec.alpha/and :portkey.aws.iot/set-as-active-flag))
(clojure.spec.alpha/def :portkey.aws.iot.register-certificate-request/status (clojure.spec.alpha/and :portkey.aws.iot/certificate-status))
(clojure.spec.alpha/def :portkey.aws.iot/register-certificate-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.register-certificate-request/certificatePem] :opt-un [:portkey.aws.iot.register-certificate-request/caCertificatePem :portkey.aws.iot.register-certificate-request/setAsActive :portkey.aws.iot.register-certificate-request/status]))

(clojure.spec.alpha/def :portkey.aws.iot/detach-thing-principal-response (portkey.awsgen/json-keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.create-thing-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.create-thing-request/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.create-thing-request/attribute-payload (clojure.spec.alpha/and :portkey.aws.iot/attribute-payload))
(clojure.spec.alpha/def :portkey.aws.iot/create-thing-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.create-thing-request/thingName] :opt-un [:portkey.aws.iot.create-thing-request/thingTypeName :portkey.aws.iot.create-thing-request/attributePayload]))

(clojure.spec.alpha/def :portkey.aws.iot/stream-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.dynamodbv2-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.dynamodbv2-action/put-item (clojure.spec.alpha/and :portkey.aws.iot/put-item-input))
(clojure.spec.alpha/def :portkey.aws.iot/dynamodbv2-action (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.dynamodbv2-action/roleArn :portkey.aws.iot.dynamodbv2-action/putItem]))

(clojure.spec.alpha/def :portkey.aws.iot/delete-registration-code-response (portkey.awsgen/json-keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.topic-rule-payload/sql (clojure.spec.alpha/and :portkey.aws.iot/sql))
(clojure.spec.alpha/def :portkey.aws.iot.topic-rule-payload/description (clojure.spec.alpha/and :portkey.aws.iot/description))
(clojure.spec.alpha/def :portkey.aws.iot.topic-rule-payload/actions (clojure.spec.alpha/and :portkey.aws.iot/action-list))
(clojure.spec.alpha/def :portkey.aws.iot.topic-rule-payload/rule-disabled (clojure.spec.alpha/and :portkey.aws.iot/is-disabled))
(clojure.spec.alpha/def :portkey.aws.iot.topic-rule-payload/aws-iot-sql-version (clojure.spec.alpha/and :portkey.aws.iot/aws-iot-sql-version))
(clojure.spec.alpha/def :portkey.aws.iot/topic-rule-payload (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.topic-rule-payload/sql :portkey.aws.iot.topic-rule-payload/actions] :opt-un [:portkey.aws.iot.topic-rule-payload/description :portkey.aws.iot.topic-rule-payload/ruleDisabled :portkey.aws.iot.topic-rule-payload/awsIotSqlVersion]))

(clojure.spec.alpha/def :portkey.aws.iot.list-principal-things-response/things (clojure.spec.alpha/and :portkey.aws.iot/thing-name-list))
(clojure.spec.alpha/def :portkey.aws.iot.list-principal-things-response/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-principal-things-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.list-principal-things-response/things :portkey.aws.iot.list-principal-things-response/nextToken]))

(clojure.spec.alpha/def :portkey.aws.iot/private-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__56601__auto__] (clojure.core/<= 1 (clojure.core/count s__56601__auto__)))))

(clojure.spec.alpha/def :portkey.aws.iot.transfer-certificate-request/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.transfer-certificate-request/target-aws-account (clojure.spec.alpha/and :portkey.aws.iot/aws-account-id))
(clojure.spec.alpha/def :portkey.aws.iot.transfer-certificate-request/transfer-message (clojure.spec.alpha/and :portkey.aws.iot/message))
(clojure.spec.alpha/def :portkey.aws.iot/transfer-certificate-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.transfer-certificate-request/certificateId :portkey.aws.iot.transfer-certificate-request/targetAwsAccount] :opt-un [:portkey.aws.iot.transfer-certificate-request/transferMessage]))

(clojure.spec.alpha/def :portkey.aws.iot/deprecation-date clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.iot.update-certificate-request/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.update-certificate-request/new-status (clojure.spec.alpha/and :portkey.aws.iot/certificate-status))
(clojure.spec.alpha/def :portkey.aws.iot/update-certificate-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.update-certificate-request/certificateId :portkey.aws.iot.update-certificate-request/newStatus] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/function-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/topic-pattern (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/rule-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__56601__auto__] (clojure.core/<= 1 (clojure.core/count s__56601__auto__))) (clojure.core/fn [s__56602__auto__] (clojure.core/< (clojure.core/count s__56602__auto__) 128)) (clojure.core/fn [s__56603__auto__] (clojure.core/re-matches #"^[a-zA-Z0-9_]+$" s__56603__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-response/default-client-id (clojure.spec.alpha/and :portkey.aws.iot/client-id))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-response/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-response/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-response/attributes (clojure.spec.alpha/and :portkey.aws.iot/attributes))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-response/version (clojure.spec.alpha/and :portkey.aws.iot/version))
(clojure.spec.alpha/def :portkey.aws.iot/describe-thing-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.describe-thing-response/defaultClientId :portkey.aws.iot.describe-thing-response/thingName :portkey.aws.iot.describe-thing-response/thingTypeName :portkey.aws.iot.describe-thing-response/attributes :portkey.aws.iot.describe-thing-response/version]))

(clojure.spec.alpha/def :portkey.aws.iot.create-keys-and-certificate-request/set-as-active (clojure.spec.alpha/and :portkey.aws.iot/set-as-active))
(clojure.spec.alpha/def :portkey.aws.iot/create-keys-and-certificate-request (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.create-keys-and-certificate-request/setAsActive]))

(clojure.spec.alpha/def :portkey.aws.iot.updatecacertificate-request/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.updatecacertificate-request/new-status (clojure.spec.alpha/and :portkey.aws.iot/cacertificate-status))
(clojure.spec.alpha/def :portkey.aws.iot.updatecacertificate-request/new-auto-registration-status (clojure.spec.alpha/and :portkey.aws.iot/auto-registration-status))
(clojure.spec.alpha/def :portkey.aws.iot/updatecacertificate-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.updatecacertificate-request/certificateId] :opt-un [:portkey.aws.iot.updatecacertificate-request/newStatus :portkey.aws.iot.updatecacertificate-request/newAutoRegistrationStatus]))

(clojure.spec.alpha/def :portkey.aws.iot.certificate-state-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/certificate-state-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.certificate-state-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot/certificate-signing-request (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__56601__auto__] (clojure.core/<= 1 (clojure.core/count s__56601__auto__)))))

(clojure.spec.alpha/def :portkey.aws.iot/page-size (clojure.spec.alpha/and clojure.core/int? (fn* [p1__56642__56643__auto__] (clojure.core/<= 1 p1__56642__56643__auto__)) (fn* [p1__56644__56645__auto__] (clojure.core/<= p1__56644__56645__auto__ 250))))

(clojure.spec.alpha/def :portkey.aws.iot.invalid-request-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/invalid-request-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.invalid-request-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot/thing-type-description (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__56602__auto__] (clojure.core/< (clojure.core/count s__56602__auto__) 2028)) (clojure.core/fn [s__56603__auto__] (clojure.core/re-matches #"[\p{Graph}\x20]*" s__56603__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.certificate-validation-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/certificate-validation-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.certificate-validation-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.thing-attribute/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.thing-attribute/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.thing-attribute/attributes (clojure.spec.alpha/and :portkey.aws.iot/attributes))
(clojure.spec.alpha/def :portkey.aws.iot.thing-attribute/version (clojure.spec.alpha/and :portkey.aws.iot/version))
(clojure.spec.alpha/def :portkey.aws.iot/thing-attribute (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.thing-attribute/thingName :portkey.aws.iot.thing-attribute/thingTypeName :portkey.aws.iot.thing-attribute/attributes :portkey.aws.iot.thing-attribute/version]))

(clojure.spec.alpha/def :portkey.aws.iot.list-topic-rules-request/topic (clojure.spec.alpha/and :portkey.aws.iot/topic))
(clojure.spec.alpha/def :portkey.aws.iot.list-topic-rules-request/max-results (clojure.spec.alpha/and :portkey.aws.iot/max-results))
(clojure.spec.alpha/def :portkey.aws.iot.list-topic-rules-request/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.list-topic-rules-request/rule-disabled (clojure.spec.alpha/and :portkey.aws.iot/is-disabled))
(clojure.spec.alpha/def :portkey.aws.iot/list-topic-rules-request (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.list-topic-rules-request/topic :portkey.aws.iot.list-topic-rules-request/maxResults :portkey.aws.iot.list-topic-rules-request/nextToken :portkey.aws.iot.list-topic-rules-request/ruleDisabled]))

(clojure.spec.alpha/def :portkey.aws.iot/canned-access-control-list (clojure.spec.alpha/conformer (clojure.core/let [m__56599__auto__ {"authenticated-read" "authenticated-read", "public-read-write" "public-read-write", :bucket-owner-full-control "bucket-owner-full-control", :private "private", "bucket-owner-full-control" "bucket-owner-full-control", "private" "private", :log-delivery-write "log-delivery-write", :authenticated-read "authenticated-read", "aws-exec-read" "aws-exec-read", :aws-exec-read "aws-exec-read", :bucket-owner-read "bucket-owner-read", "bucket-owner-read" "bucket-owner-read", "public-read" "public-read", "log-delivery-write" "log-delivery-write", :public-read-write "public-read-write", :public-read "public-read"}] (clojure.core/fn [s__56600__auto__] (m__56599__auto__ s__56600__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.awsgen/dashed)))

(clojure.spec.alpha/def :portkey.aws.iot.list-outgoing-certificates-request/page-size (clojure.spec.alpha/and :portkey.aws.iot/page-size))
(clojure.spec.alpha/def :portkey.aws.iot.list-outgoing-certificates-request/marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot.list-outgoing-certificates-request/ascending-order (clojure.spec.alpha/and :portkey.aws.iot/ascending-order))
(clojure.spec.alpha/def :portkey.aws.iot/list-outgoing-certificates-request (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.list-outgoing-certificates-request/pageSize :portkey.aws.iot.list-outgoing-certificates-request/marker :portkey.aws.iot.list-outgoing-certificates-request/ascendingOrder]))

(clojure.spec.alpha/def :portkey.aws.iot/thing-type-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__56601__auto__] (clojure.core/<= 1 (clojure.core/count s__56601__auto__))) (clojure.core/fn [s__56602__auto__] (clojure.core/< (clojure.core/count s__56602__auto__) 128)) (clojure.core/fn [s__56603__auto__] (clojure.core/re-matches #"[a-zA-Z0-9:_-]+" s__56603__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.list-principal-policies-request/principal (clojure.spec.alpha/and :portkey.aws.iot/principal))
(clojure.spec.alpha/def :portkey.aws.iot.list-principal-policies-request/marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot.list-principal-policies-request/page-size (clojure.spec.alpha/and :portkey.aws.iot/page-size))
(clojure.spec.alpha/def :portkey.aws.iot.list-principal-policies-request/ascending-order (clojure.spec.alpha/and :portkey.aws.iot/ascending-order))
(clojure.spec.alpha/def :portkey.aws.iot/list-principal-policies-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.list-principal-policies-request/principal] :opt-un [:portkey.aws.iot.list-principal-policies-request/marker :portkey.aws.iot.list-principal-policies-request/pageSize :portkey.aws.iot.list-principal-policies-request/ascendingOrder]))

(clojure.spec.alpha/def :portkey.aws.iot/resource-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.get-logging-options-response/role-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.get-logging-options-response/log-level (clojure.spec.alpha/and :portkey.aws.iot/log-level))
(clojure.spec.alpha/def :portkey.aws.iot/get-logging-options-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.get-logging-options-response/roleArn :portkey.aws.iot.get-logging-options-response/logLevel]))

(clojure.spec.alpha/def :portkey.aws.iot/attribute-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__56602__auto__] (clojure.core/< (clojure.core/count s__56602__auto__) 128)) (clojure.core/fn [s__56603__auto__] (clojure.core/re-matches #"[a-zA-Z0-9_.,@/:#-]+" s__56603__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.outgoing-certificate/certificate-arn (clojure.spec.alpha/and :portkey.aws.iot/certificate-arn))
(clojure.spec.alpha/def :portkey.aws.iot.outgoing-certificate/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.outgoing-certificate/transferred-to (clojure.spec.alpha/and :portkey.aws.iot/aws-account-id))
(clojure.spec.alpha/def :portkey.aws.iot.outgoing-certificate/transfer-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.outgoing-certificate/transfer-message (clojure.spec.alpha/and :portkey.aws.iot/message))
(clojure.spec.alpha/def :portkey.aws.iot.outgoing-certificate/creation-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot/outgoing-certificate (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.outgoing-certificate/certificateArn :portkey.aws.iot.outgoing-certificate/certificateId :portkey.aws.iot.outgoing-certificate/transferredTo :portkey.aws.iot.outgoing-certificate/transferDate :portkey.aws.iot.outgoing-certificate/transferMessage :portkey.aws.iot.outgoing-certificate/creationDate]))

(clojure.spec.alpha/def :portkey.aws.iot.list-certificates-response/certificates (clojure.spec.alpha/and :portkey.aws.iot/certificates))
(clojure.spec.alpha/def :portkey.aws.iot.list-certificates-response/next-marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot/list-certificates-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.list-certificates-response/certificates :portkey.aws.iot.list-certificates-response/nextMarker]))

(clojure.spec.alpha/def :portkey.aws.iot.set-default-policy-version-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.set-default-policy-version-request/policy-version-id (clojure.spec.alpha/and :portkey.aws.iot/policy-version-id))
(clojure.spec.alpha/def :portkey.aws.iot/set-default-policy-version-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.set-default-policy-version-request/policyName :portkey.aws.iot.set-default-policy-version-request/policyVersionId] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.enable-topic-rule-request/rule-name (clojure.spec.alpha/and :portkey.aws.iot/rule-name))
(clojure.spec.alpha/def :portkey.aws.iot/enable-topic-rule-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.enable-topic-rule-request/ruleName] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/log-level (clojure.spec.alpha/conformer (clojure.core/let [m__56599__auto__ {"DISABLED" "DISABLED", :disabled "DISABLED", :warn "WARN", "WARN" "WARN", :debug "DEBUG", "ERROR" "ERROR", "DEBUG" "DEBUG", :info "INFO", :error "ERROR", "INFO" "INFO"}] (clojure.core/fn [s__56600__auto__] (m__56599__auto__ s__56600__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.awsgen/dashed)))

(clojure.spec.alpha/def :portkey.aws.iot/policy-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__56601__auto__] (clojure.core/<= 1 (clojure.core/count s__56601__auto__))) (clojure.core/fn [s__56602__auto__] (clojure.core/< (clojure.core/count s__56602__auto__) 128)) (clojure.core/fn [s__56603__auto__] (clojure.core/re-matches #"[\w+=,.@-]+" s__56603__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot/cacertificates (clojure.spec.alpha/coll-of :portkey.aws.iot/cacertificate :max-count nil))

(clojure.spec.alpha/def :portkey.aws.iot/error-message (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/action-list (clojure.spec.alpha/coll-of :portkey.aws.iot/action :max-count 10))

(clojure.spec.alpha/def :portkey.aws.iot.reject-certificate-transfer-request/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.reject-certificate-transfer-request/reject-reason (clojure.spec.alpha/and :portkey.aws.iot/message))
(clojure.spec.alpha/def :portkey.aws.iot/reject-certificate-transfer-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.reject-certificate-transfer-request/certificateId] :opt-un [:portkey.aws.iot.reject-certificate-transfer-request/rejectReason]))

(clojure.spec.alpha/def :portkey.aws.iot.list-certificates-request/page-size (clojure.spec.alpha/and :portkey.aws.iot/page-size))
(clojure.spec.alpha/def :portkey.aws.iot.list-certificates-request/marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot.list-certificates-request/ascending-order (clojure.spec.alpha/and :portkey.aws.iot/ascending-order))
(clojure.spec.alpha/def :portkey.aws.iot/list-certificates-request (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.list-certificates-request/pageSize :portkey.aws.iot.list-certificates-request/marker :portkey.aws.iot.list-certificates-request/ascendingOrder]))

(clojure.spec.alpha/def :portkey.aws.iot/thing-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot/describe-thing-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.describe-thing-request/thingName] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.get-topic-rule-response/rule-arn (clojure.spec.alpha/and :portkey.aws.iot/rule-arn))
(clojure.spec.alpha/def :portkey.aws.iot.get-topic-rule-response/rule (clojure.spec.alpha/and :portkey.aws.iot/topic-rule))
(clojure.spec.alpha/def :portkey.aws.iot/get-topic-rule-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.get-topic-rule-response/ruleArn :portkey.aws.iot.get-topic-rule-response/rule]))

(clojure.spec.alpha/def :portkey.aws.iot/certificates (clojure.spec.alpha/coll-of :portkey.aws.iot/certificate :max-count nil))

(clojure.spec.alpha/def :portkey.aws.iot.thing-type-metadata/deprecated (clojure.spec.alpha/and :portkey.aws.iot/boolean))
(clojure.spec.alpha/def :portkey.aws.iot.thing-type-metadata/deprecation-date (clojure.spec.alpha/and :portkey.aws.iot/deprecation-date))
(clojure.spec.alpha/def :portkey.aws.iot.thing-type-metadata/creation-date (clojure.spec.alpha/and :portkey.aws.iot/creation-date))
(clojure.spec.alpha/def :portkey.aws.iot/thing-type-metadata (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.thing-type-metadata/deprecated :portkey.aws.iot.thing-type-metadata/deprecationDate :portkey.aws.iot.thing-type-metadata/creationDate]))

(clojure.spec.alpha/def :portkey.aws.iot.attribute-payload/attributes (clojure.spec.alpha/and :portkey.aws.iot/attributes))
(clojure.spec.alpha/def :portkey.aws.iot.attribute-payload/merge (clojure.spec.alpha/and :portkey.aws.iot/flag))
(clojure.spec.alpha/def :portkey.aws.iot/attribute-payload (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.attribute-payload/attributes :portkey.aws.iot.attribute-payload/merge]))

(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-type-request/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot/describe-thing-type-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.describe-thing-type-request/thingTypeName] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.describecacertificate-response/certificate-description (clojure.spec.alpha/and :portkey.aws.iot/cacertificate-description))
(clojure.spec.alpha/def :portkey.aws.iot/describecacertificate-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.describecacertificate-response/certificateDescription]))

(clojure.spec.alpha/def :portkey.aws.iot/state-value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/use-base64 clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.describe-certificate-request/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot/describe-certificate-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.describe-certificate-request/certificateId] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/principal-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.list-thing-types-request/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.list-thing-types-request/max-results (clojure.spec.alpha/and :portkey.aws.iot/registry-max-results))
(clojure.spec.alpha/def :portkey.aws.iot.list-thing-types-request/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot/list-thing-types-request (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.list-thing-types-request/nextToken :portkey.aws.iot.list-thing-types-request/maxResults :portkey.aws.iot.list-thing-types-request/thingTypeName]))

(clojure.spec.alpha/def :portkey.aws.iot/cacertificate-status (clojure.spec.alpha/conformer (clojure.core/let [m__56599__auto__ {"ACTIVE" "ACTIVE", :active "ACTIVE", "INACTIVE" "INACTIVE", :inactive "INACTIVE"}] (clojure.core/fn [s__56600__auto__] (m__56599__auto__ s__56600__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.awsgen/dashed)))

(clojure.spec.alpha/def :portkey.aws.iot/partition-key (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.delete-thing-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.delete-thing-request/expected-version (clojure.spec.alpha/and :portkey.aws.iot/optional-version))
(clojure.spec.alpha/def :portkey.aws.iot/delete-thing-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.delete-thing-request/thingName] :opt-un [:portkey.aws.iot.delete-thing-request/expectedVersion]))

(clojure.spec.alpha/def :portkey.aws.iot.list-principal-policies-response/policies (clojure.spec.alpha/and :portkey.aws.iot/policies))
(clojure.spec.alpha/def :portkey.aws.iot.list-principal-policies-response/next-marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot/list-principal-policies-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.list-principal-policies-response/policies :portkey.aws.iot.list-principal-policies-response/nextMarker]))

(clojure.spec.alpha/def :portkey.aws.iot/flag clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.certificate-description/creation-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.certificate-description/certificate-pem (clojure.spec.alpha/and :portkey.aws.iot/certificate-pem))
(clojure.spec.alpha/def :portkey.aws.iot.certificate-description/ca-certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.certificate-description/last-modified-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.certificate-description/owned-by (clojure.spec.alpha/and :portkey.aws.iot/aws-account-id))
(clojure.spec.alpha/def :portkey.aws.iot.certificate-description/transfer-data (clojure.spec.alpha/and :portkey.aws.iot/transfer-data))
(clojure.spec.alpha/def :portkey.aws.iot.certificate-description/status (clojure.spec.alpha/and :portkey.aws.iot/certificate-status))
(clojure.spec.alpha/def :portkey.aws.iot.certificate-description/previous-owned-by (clojure.spec.alpha/and :portkey.aws.iot/aws-account-id))
(clojure.spec.alpha/def :portkey.aws.iot.certificate-description/certificate-arn (clojure.spec.alpha/and :portkey.aws.iot/certificate-arn))
(clojure.spec.alpha/def :portkey.aws.iot.certificate-description/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot/certificate-description (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.certificate-description/creationDate :portkey.aws.iot.certificate-description/certificatePem :portkey.aws.iot.certificate-description/caCertificateId :portkey.aws.iot.certificate-description/lastModifiedDate :portkey.aws.iot.certificate-description/ownedBy :portkey.aws.iot.certificate-description/transferData :portkey.aws.iot.certificate-description/status :portkey.aws.iot.certificate-description/previousOwnedBy :portkey.aws.iot.certificate-description/certificateArn :portkey.aws.iot.certificate-description/certificateId]))

(clojure.spec.alpha/def :portkey.aws.iot.delete-conflict-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/delete-conflict-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.delete-conflict-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot/marker (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.detach-thing-principal-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.detach-thing-principal-request/principal (clojure.spec.alpha/and :portkey.aws.iot/principal))
(clojure.spec.alpha/def :portkey.aws.iot/detach-thing-principal-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.detach-thing-principal-request/thingName :portkey.aws.iot.detach-thing-principal-request/principal] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/rule-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.transfer-certificate-response/transferred-certificate-arn (clojure.spec.alpha/and :portkey.aws.iot/certificate-arn))
(clojure.spec.alpha/def :portkey.aws.iot/transfer-certificate-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.transfer-certificate-response/transferredCertificateArn]))

(clojure.spec.alpha/def :portkey.aws.iot.limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/limit-exceeded-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.limit-exceeded-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.thing-type-definition/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.thing-type-definition/thing-type-properties (clojure.spec.alpha/and :portkey.aws.iot/thing-type-properties))
(clojure.spec.alpha/def :portkey.aws.iot.thing-type-definition/thing-type-metadata (clojure.spec.alpha/and :portkey.aws.iot/thing-type-metadata))
(clojure.spec.alpha/def :portkey.aws.iot/thing-type-definition (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.thing-type-definition/thingTypeName :portkey.aws.iot.thing-type-definition/thingTypeProperties :portkey.aws.iot.thing-type-definition/thingTypeMetadata]))

(clojure.spec.alpha/def :portkey.aws.iot/deprecate-thing-type-response (portkey.awsgen/json-keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.list-topic-rules-response/rules (clojure.spec.alpha/and :portkey.aws.iot/topic-rule-list))
(clojure.spec.alpha/def :portkey.aws.iot.list-topic-rules-response/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-topic-rules-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.list-topic-rules-response/rules :portkey.aws.iot.list-topic-rules-response/nextToken]))

(clojure.spec.alpha/def :portkey.aws.iot/thing-name-list (clojure.spec.alpha/coll-of :portkey.aws.iot/thing-name :max-count nil))

(clojure.spec.alpha/def :portkey.aws.iot.create-certificate-from-csr-request/certificate-signing-request (clojure.spec.alpha/and :portkey.aws.iot/certificate-signing-request))
(clojure.spec.alpha/def :portkey.aws.iot.create-certificate-from-csr-request/set-as-active (clojure.spec.alpha/and :portkey.aws.iot/set-as-active))
(clojure.spec.alpha/def :portkey.aws.iot/create-certificate-from-csr-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.create-certificate-from-csr-request/certificateSigningRequest] :opt-un [:portkey.aws.iot.create-certificate-from-csr-request/setAsActive]))

(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-type-response/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-type-response/thing-type-properties (clojure.spec.alpha/and :portkey.aws.iot/thing-type-properties))
(clojure.spec.alpha/def :portkey.aws.iot.describe-thing-type-response/thing-type-metadata (clojure.spec.alpha/and :portkey.aws.iot/thing-type-metadata))
(clojure.spec.alpha/def :portkey.aws.iot/describe-thing-type-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.describe-thing-type-response/thingTypeName :portkey.aws.iot.describe-thing-type-response/thingTypeProperties :portkey.aws.iot.describe-thing-type-response/thingTypeMetadata]))

(clojure.spec.alpha/def :portkey.aws.iot/elasticsearch-type (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.delete-topic-rule-request/rule-name (clojure.spec.alpha/and :portkey.aws.iot/rule-name))
(clojure.spec.alpha/def :portkey.aws.iot/delete-topic-rule-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.delete-topic-rule-request/ruleName] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/set-as-active-flag clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot/thing-type-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.resource-already-exists-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/resource-already-exists-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.resource-already-exists-exception/message :portkey.aws.iot/resourceId :portkey.aws.iot/resourceArn]))

(clojure.spec.alpha/def :portkey.aws.iot.list-certificates-bycaresponse/certificates (clojure.spec.alpha/and :portkey.aws.iot/certificates))
(clojure.spec.alpha/def :portkey.aws.iot.list-certificates-bycaresponse/next-marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot/list-certificates-bycaresponse (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.list-certificates-bycaresponse/certificates :portkey.aws.iot.list-certificates-bycaresponse/nextMarker]))

(clojure.spec.alpha/def :portkey.aws.iot.list-thing-principals-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot/list-thing-principals-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.list-thing-principals-request/thingName] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.listcacertificates-response/certificates (clojure.spec.alpha/and :portkey.aws.iot/cacertificates))
(clojure.spec.alpha/def :portkey.aws.iot.listcacertificates-response/next-marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot/listcacertificates-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.listcacertificates-response/certificates :portkey.aws.iot.listcacertificates-response/nextMarker]))

(clojure.spec.alpha/def :portkey.aws.iot.service-unavailable-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/service-unavailable-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.service-unavailable-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.create-keys-and-certificate-response/certificate-arn (clojure.spec.alpha/and :portkey.aws.iot/certificate-arn))
(clojure.spec.alpha/def :portkey.aws.iot.create-keys-and-certificate-response/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.create-keys-and-certificate-response/certificate-pem (clojure.spec.alpha/and :portkey.aws.iot/certificate-pem))
(clojure.spec.alpha/def :portkey.aws.iot.create-keys-and-certificate-response/key-pair (clojure.spec.alpha/and :portkey.aws.iot/key-pair))
(clojure.spec.alpha/def :portkey.aws.iot/create-keys-and-certificate-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.create-keys-and-certificate-response/certificateArn :portkey.aws.iot.create-keys-and-certificate-response/certificateId :portkey.aws.iot.create-keys-and-certificate-response/certificatePem :portkey.aws.iot.create-keys-and-certificate-response/keyPair]))

(clojure.spec.alpha/def :portkey.aws.iot/aws-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/delete-registration-code-request (portkey.awsgen/json-keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/metric-unit (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/allow-auto-registration clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.policy-version/version-id (clojure.spec.alpha/and :portkey.aws.iot/policy-version-id))
(clojure.spec.alpha/def :portkey.aws.iot.policy-version/is-default-version (clojure.spec.alpha/and :portkey.aws.iot/is-default-version))
(clojure.spec.alpha/def :portkey.aws.iot.policy-version/create-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot/policy-version (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.policy-version/versionId :portkey.aws.iot.policy-version/isDefaultVersion :portkey.aws.iot.policy-version/createDate]))

(clojure.spec.alpha/def :portkey.aws.iot.put-item-input/table-name (clojure.spec.alpha/and :portkey.aws.iot/table-name))
(clojure.spec.alpha/def :portkey.aws.iot/put-item-input (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.put-item-input/tableName] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/next-token (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.deletecacertificate-request/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot/deletecacertificate-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.deletecacertificate-request/certificateId] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/range-key-value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/hash-key-value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.firehose-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.firehose-action/delivery-stream-name (clojure.spec.alpha/and :portkey.aws.iot/delivery-stream-name))
(clojure.spec.alpha/def :portkey.aws.iot.firehose-action/separator (clojure.spec.alpha/and :portkey.aws.iot/firehose-separator))
(clojure.spec.alpha/def :portkey.aws.iot/firehose-action (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.firehose-action/roleArn :portkey.aws.iot.firehose-action/deliveryStreamName] :opt-un [:portkey.aws.iot.firehose-action/separator]))

(clojure.spec.alpha/def :portkey.aws.iot/metric-timestamp (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/topic (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.get-topic-rule-request/rule-name (clojure.spec.alpha/and :portkey.aws.iot/rule-name))
(clojure.spec.alpha/def :portkey.aws.iot/get-topic-rule-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.get-topic-rule-request/ruleName] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.create-policy-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.create-policy-request/policy-document (clojure.spec.alpha/and :portkey.aws.iot/policy-document))
(clojure.spec.alpha/def :portkey.aws.iot/create-policy-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.create-policy-request/policyName :portkey.aws.iot.create-policy-request/policyDocument] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.attach-principal-policy-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.attach-principal-policy-request/principal (clojure.spec.alpha/and :portkey.aws.iot/principal))
(clojure.spec.alpha/def :portkey.aws.iot/attach-principal-policy-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.attach-principal-policy-request/policyName :portkey.aws.iot.attach-principal-policy-request/principal] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/key (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/salesforce-token (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__56601__auto__] (clojure.core/<= 40 (clojure.core/count s__56601__auto__)))))

(clojure.spec.alpha/def :portkey.aws.iot/attributes (clojure.spec.alpha/map-of :portkey.aws.iot/attribute-name :portkey.aws.iot/attribute-value))

(clojure.spec.alpha/def :portkey.aws.iot.create-certificate-from-csr-response/certificate-arn (clojure.spec.alpha/and :portkey.aws.iot/certificate-arn))
(clojure.spec.alpha/def :portkey.aws.iot.create-certificate-from-csr-response/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.create-certificate-from-csr-response/certificate-pem (clojure.spec.alpha/and :portkey.aws.iot/certificate-pem))
(clojure.spec.alpha/def :portkey.aws.iot/create-certificate-from-csr-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.create-certificate-from-csr-response/certificateArn :portkey.aws.iot.create-certificate-from-csr-response/certificateId :portkey.aws.iot.create-certificate-from-csr-response/certificatePem]))

(clojure.spec.alpha/def :portkey.aws.iot/queue-url (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.internal-failure-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/internal-failure-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.internal-failure-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.get-policy-version-response/policy-arn (clojure.spec.alpha/and :portkey.aws.iot/policy-arn))
(clojure.spec.alpha/def :portkey.aws.iot.get-policy-version-response/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.get-policy-version-response/policy-document (clojure.spec.alpha/and :portkey.aws.iot/policy-document))
(clojure.spec.alpha/def :portkey.aws.iot.get-policy-version-response/policy-version-id (clojure.spec.alpha/and :portkey.aws.iot/policy-version-id))
(clojure.spec.alpha/def :portkey.aws.iot.get-policy-version-response/is-default-version (clojure.spec.alpha/and :portkey.aws.iot/is-default-version))
(clojure.spec.alpha/def :portkey.aws.iot/get-policy-version-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.get-policy-version-response/policyArn :portkey.aws.iot.get-policy-version-response/policyName :portkey.aws.iot.get-policy-version-response/policyDocument :portkey.aws.iot.get-policy-version-response/policyVersionId :portkey.aws.iot.get-policy-version-response/isDefaultVersion]))

(clojure.spec.alpha/def :portkey.aws.iot.versions-limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/versions-limit-exceeded-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.versions-limit-exceeded-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot/searchable-attributes (clojure.spec.alpha/coll-of :portkey.aws.iot/attribute-name :max-count nil))

(clojure.spec.alpha/def :portkey.aws.iot/message-format (clojure.spec.alpha/conformer (clojure.core/let [m__56599__auto__ {"RAW" "RAW", :raw "RAW", "JSON" "JSON", :json "JSON"}] (clojure.core/fn [s__56600__auto__] (m__56599__auto__ s__56600__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.awsgen/dashed)))

(clojure.spec.alpha/def :portkey.aws.iot/date-type clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.iot/attribute-value (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__56602__auto__] (clojure.core/< (clojure.core/count s__56602__auto__) 800)) (clojure.core/fn [s__56603__auto__] (clojure.core/re-matches #"[a-zA-Z0-9_.,@/:#-]*" s__56603__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.listcacertificates-request/page-size (clojure.spec.alpha/and :portkey.aws.iot/page-size))
(clojure.spec.alpha/def :portkey.aws.iot.listcacertificates-request/marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot.listcacertificates-request/ascending-order (clojure.spec.alpha/and :portkey.aws.iot/ascending-order))
(clojure.spec.alpha/def :portkey.aws.iot/listcacertificates-request (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.listcacertificates-request/pageSize :portkey.aws.iot.listcacertificates-request/marker :portkey.aws.iot.listcacertificates-request/ascendingOrder]))

(clojure.spec.alpha/def :portkey.aws.iot/dynamo-key-type (clojure.spec.alpha/conformer (clojure.core/let [m__56599__auto__ {"STRING" "STRING", :string "STRING", "NUMBER" "NUMBER", :number "NUMBER"}] (clojure.core/fn [s__56600__auto__] (m__56599__auto__ s__56600__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.awsgen/dashed)))

(clojure.spec.alpha/def :portkey.aws.iot.delete-certificate-request/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot/delete-certificate-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.delete-certificate-request/certificateId] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.cancel-certificate-transfer-request/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot/cancel-certificate-transfer-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.cancel-certificate-transfer-request/certificateId] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.get-policy-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot/get-policy-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.get-policy-request/policyName] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.get-registration-code-response/registration-code (clojure.spec.alpha/and :portkey.aws.iot/registration-code))
(clojure.spec.alpha/def :portkey.aws.iot/get-registration-code-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.get-registration-code-response/registrationCode]))

(clojure.spec.alpha/def :portkey.aws.iot/get-logging-options-request (portkey.awsgen/json-keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.resource-not-found-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/resource-not-found-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.resource-not-found-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.sns-action/target-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.sns-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.sns-action/message-format (clojure.spec.alpha/and :portkey.aws.iot/message-format))
(clojure.spec.alpha/def :portkey.aws.iot/sns-action (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.sns-action/targetArn :portkey.aws.iot.sns-action/roleArn] :opt-un [:portkey.aws.iot.sns-action/messageFormat]))

(clojure.spec.alpha/def :portkey.aws.iot/undo-deprecate clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot/delete-thing-type-response (portkey.awsgen/json-keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/deletecacertificate-response (portkey.awsgen/json-keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.delete-thing-type-request/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot/delete-thing-type-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.delete-thing-type-request/thingTypeName] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.delete-policy-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot/delete-policy-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.delete-policy-request/policyName] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/description (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.delete-policy-version-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.delete-policy-version-request/policy-version-id (clojure.spec.alpha/and :portkey.aws.iot/policy-version-id))
(clojure.spec.alpha/def :portkey.aws.iot/delete-policy-version-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.delete-policy-version-request/policyName :portkey.aws.iot.delete-policy-version-request/policyVersionId] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/policy-document (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/aws-account-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__56603__auto__] (clojure.core/re-matches #"[0-9]{12}" s__56603__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot/message (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__56602__auto__] (clojure.core/< (clojure.core/count s__56602__auto__) 128))))

(clojure.spec.alpha/def :portkey.aws.iot/is-disabled clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.sql-parse-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/sql-parse-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.sql-parse-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.internal-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/internal-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.internal-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.get-policy-response/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.get-policy-response/policy-arn (clojure.spec.alpha/and :portkey.aws.iot/policy-arn))
(clojure.spec.alpha/def :portkey.aws.iot.get-policy-response/policy-document (clojure.spec.alpha/and :portkey.aws.iot/policy-document))
(clojure.spec.alpha/def :portkey.aws.iot.get-policy-response/default-version-id (clojure.spec.alpha/and :portkey.aws.iot/policy-version-id))
(clojure.spec.alpha/def :portkey.aws.iot/get-policy-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.get-policy-response/policyName :portkey.aws.iot.get-policy-response/policyArn :portkey.aws.iot.get-policy-response/policyDocument :portkey.aws.iot.get-policy-response/defaultVersionId]))

(clojure.spec.alpha/def :portkey.aws.iot.cloudwatch-metric-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.cloudwatch-metric-action/metric-namespace (clojure.spec.alpha/and :portkey.aws.iot/metric-namespace))
(clojure.spec.alpha/def :portkey.aws.iot.cloudwatch-metric-action/metric-name (clojure.spec.alpha/and :portkey.aws.iot/metric-name))
(clojure.spec.alpha/def :portkey.aws.iot.cloudwatch-metric-action/metric-value (clojure.spec.alpha/and :portkey.aws.iot/metric-value))
(clojure.spec.alpha/def :portkey.aws.iot.cloudwatch-metric-action/metric-unit (clojure.spec.alpha/and :portkey.aws.iot/metric-unit))
(clojure.spec.alpha/def :portkey.aws.iot.cloudwatch-metric-action/metric-timestamp (clojure.spec.alpha/and :portkey.aws.iot/metric-timestamp))
(clojure.spec.alpha/def :portkey.aws.iot/cloudwatch-metric-action (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.cloudwatch-metric-action/roleArn :portkey.aws.iot.cloudwatch-metric-action/metricNamespace :portkey.aws.iot.cloudwatch-metric-action/metricName :portkey.aws.iot.cloudwatch-metric-action/metricValue :portkey.aws.iot.cloudwatch-metric-action/metricUnit] :opt-un [:portkey.aws.iot.cloudwatch-metric-action/metricTimestamp]))

(clojure.spec.alpha/def :portkey.aws.iot.version-conflict-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/version-conflict-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.version-conflict-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.create-policy-response/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.create-policy-response/policy-arn (clojure.spec.alpha/and :portkey.aws.iot/policy-arn))
(clojure.spec.alpha/def :portkey.aws.iot.create-policy-response/policy-document (clojure.spec.alpha/and :portkey.aws.iot/policy-document))
(clojure.spec.alpha/def :portkey.aws.iot.create-policy-response/policy-version-id (clojure.spec.alpha/and :portkey.aws.iot/policy-version-id))
(clojure.spec.alpha/def :portkey.aws.iot/create-policy-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.create-policy-response/policyName :portkey.aws.iot.create-policy-response/policyArn :portkey.aws.iot.create-policy-response/policyDocument :portkey.aws.iot.create-policy-response/policyVersionId]))

(clojure.spec.alpha/def :portkey.aws.iot/remove-thing-type clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot/delivery-stream-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.attach-thing-principal-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.attach-thing-principal-request/principal (clojure.spec.alpha/and :portkey.aws.iot/principal))
(clojure.spec.alpha/def :portkey.aws.iot/attach-thing-principal-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.attach-thing-principal-request/thingName :portkey.aws.iot.attach-thing-principal-request/principal] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.sqs-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.sqs-action/queue-url (clojure.spec.alpha/and :portkey.aws.iot/queue-url))
(clojure.spec.alpha/def :portkey.aws.iot.sqs-action/use-base64 (clojure.spec.alpha/and :portkey.aws.iot/use-base64))
(clojure.spec.alpha/def :portkey.aws.iot/sqs-action (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.sqs-action/roleArn :portkey.aws.iot.sqs-action/queueUrl] :opt-un [:portkey.aws.iot.sqs-action/useBase64]))

(clojure.spec.alpha/def :portkey.aws.iot.list-policy-versions-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot/list-policy-versions-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.list-policy-versions-request/policyName] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.get-policy-version-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.get-policy-version-request/policy-version-id (clojure.spec.alpha/and :portkey.aws.iot/policy-version-id))
(clojure.spec.alpha/def :portkey.aws.iot/get-policy-version-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.get-policy-version-request/policyName :portkey.aws.iot.get-policy-version-request/policyVersionId] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/update-thing-response (portkey.awsgen/json-keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/policy-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.list-principal-things-request/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.list-principal-things-request/max-results (clojure.spec.alpha/and :portkey.aws.iot/registry-max-results))
(clojure.spec.alpha/def :portkey.aws.iot.list-principal-things-request/principal (clojure.spec.alpha/and :portkey.aws.iot/principal))
(clojure.spec.alpha/def :portkey.aws.iot/list-principal-things-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.list-principal-things-request/principal] :opt-un [:portkey.aws.iot.list-principal-things-request/nextToken :portkey.aws.iot.list-principal-things-request/maxResults]))

(clojure.spec.alpha/def :portkey.aws.iot.describe-certificate-response/certificate-description (clojure.spec.alpha/and :portkey.aws.iot/certificate-description))
(clojure.spec.alpha/def :portkey.aws.iot/describe-certificate-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.describe-certificate-response/certificateDescription]))

(clojure.spec.alpha/def :portkey.aws.iot/describe-endpoint-request (portkey.awsgen/json-keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.list-certificates-bycarequest/ca-certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.list-certificates-bycarequest/page-size (clojure.spec.alpha/and :portkey.aws.iot/page-size))
(clojure.spec.alpha/def :portkey.aws.iot.list-certificates-bycarequest/marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot.list-certificates-bycarequest/ascending-order (clojure.spec.alpha/and :portkey.aws.iot/ascending-order))
(clojure.spec.alpha/def :portkey.aws.iot/list-certificates-bycarequest (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.list-certificates-bycarequest/caCertificateId] :opt-un [:portkey.aws.iot.list-certificates-bycarequest/pageSize :portkey.aws.iot.list-certificates-bycarequest/marker :portkey.aws.iot.list-certificates-bycarequest/ascendingOrder]))

(clojure.spec.alpha/def :portkey.aws.iot/alarm-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/hash-key-field (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/thing-name (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__56601__auto__] (clojure.core/<= 1 (clojure.core/count s__56601__auto__))) (clojure.core/fn [s__56602__auto__] (clojure.core/< (clojure.core/count s__56602__auto__) 128)) (clojure.core/fn [s__56603__auto__] (clojure.core/re-matches #"[a-zA-Z0-9:_-]+" s__56603__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.republish-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.republish-action/topic (clojure.spec.alpha/and :portkey.aws.iot/topic-pattern))
(clojure.spec.alpha/def :portkey.aws.iot/republish-action (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.republish-action/roleArn :portkey.aws.iot.republish-action/topic] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.registercacertificate-request/ca-certificate (clojure.spec.alpha/and :portkey.aws.iot/certificate-pem))
(clojure.spec.alpha/def :portkey.aws.iot.registercacertificate-request/verification-certificate (clojure.spec.alpha/and :portkey.aws.iot/certificate-pem))
(clojure.spec.alpha/def :portkey.aws.iot.registercacertificate-request/set-as-active (clojure.spec.alpha/and :portkey.aws.iot/set-as-active))
(clojure.spec.alpha/def :portkey.aws.iot.registercacertificate-request/allow-auto-registration (clojure.spec.alpha/and :portkey.aws.iot/allow-auto-registration))
(clojure.spec.alpha/def :portkey.aws.iot/registercacertificate-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.registercacertificate-request/caCertificate :portkey.aws.iot.registercacertificate-request/verificationCertificate] :opt-un [:portkey.aws.iot.registercacertificate-request/setAsActive :portkey.aws.iot.registercacertificate-request/allowAutoRegistration]))

(clojure.spec.alpha/def :portkey.aws.iot.list-policies-request/marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot.list-policies-request/page-size (clojure.spec.alpha/and :portkey.aws.iot/page-size))
(clojure.spec.alpha/def :portkey.aws.iot.list-policies-request/ascending-order (clojure.spec.alpha/and :portkey.aws.iot/ascending-order))
(clojure.spec.alpha/def :portkey.aws.iot/list-policies-request (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.list-policies-request/marker :portkey.aws.iot.list-policies-request/pageSize :portkey.aws.iot.list-policies-request/ascendingOrder]))

(clojure.spec.alpha/def :portkey.aws.iot.register-certificate-response/certificate-arn (clojure.spec.alpha/and :portkey.aws.iot/certificate-arn))
(clojure.spec.alpha/def :portkey.aws.iot.register-certificate-response/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot/register-certificate-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.register-certificate-response/certificateArn :portkey.aws.iot.register-certificate-response/certificateId]))

(clojure.spec.alpha/def :portkey.aws.iot/metric-value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/client-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.transfer-already-completed-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/transfer-already-completed-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.transfer-already-completed-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.list-thing-principals-response/principals (clojure.spec.alpha/and :portkey.aws.iot/principals))
(clojure.spec.alpha/def :portkey.aws.iot/list-thing-principals-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.list-thing-principals-response/principals]))

(clojure.spec.alpha/def :portkey.aws.iot.elasticsearch-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.elasticsearch-action/endpoint (clojure.spec.alpha/and :portkey.aws.iot/elasticsearch-endpoint))
(clojure.spec.alpha/def :portkey.aws.iot.elasticsearch-action/index (clojure.spec.alpha/and :portkey.aws.iot/elasticsearch-index))
(clojure.spec.alpha/def :portkey.aws.iot.elasticsearch-action/type (clojure.spec.alpha/and :portkey.aws.iot/elasticsearch-type))
(clojure.spec.alpha/def :portkey.aws.iot.elasticsearch-action/id (clojure.spec.alpha/and :portkey.aws.iot/elasticsearch-id))
(clojure.spec.alpha/def :portkey.aws.iot/elasticsearch-action (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.elasticsearch-action/roleArn :portkey.aws.iot.elasticsearch-action/endpoint :portkey.aws.iot.elasticsearch-action/index :portkey.aws.iot.elasticsearch-action/type :portkey.aws.iot.elasticsearch-action/id] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/elasticsearch-index (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/policies (clojure.spec.alpha/coll-of :portkey.aws.iot/policy :max-count nil))

(clojure.spec.alpha/def :portkey.aws.iot/certificate-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/set-as-active clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot/table-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/aws-iot-sql-version (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.disable-topic-rule-request/rule-name (clojure.spec.alpha/and :portkey.aws.iot/rule-name))
(clojure.spec.alpha/def :portkey.aws.iot/disable-topic-rule-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.disable-topic-rule-request/ruleName] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/sql (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/creation-date clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.iot.dynamodbaction/range-key-value (clojure.spec.alpha/and :portkey.aws.iot/range-key-value))
(clojure.spec.alpha/def :portkey.aws.iot.dynamodbaction/table-name (clojure.spec.alpha/and :portkey.aws.iot/table-name))
(clojure.spec.alpha/def :portkey.aws.iot.dynamodbaction/hash-key-value (clojure.spec.alpha/and :portkey.aws.iot/hash-key-value))
(clojure.spec.alpha/def :portkey.aws.iot.dynamodbaction/role-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.dynamodbaction/range-key-field (clojure.spec.alpha/and :portkey.aws.iot/range-key-field))
(clojure.spec.alpha/def :portkey.aws.iot.dynamodbaction/hash-key-type (clojure.spec.alpha/and :portkey.aws.iot/dynamo-key-type))
(clojure.spec.alpha/def :portkey.aws.iot.dynamodbaction/operation (clojure.spec.alpha/and :portkey.aws.iot/dynamo-operation))
(clojure.spec.alpha/def :portkey.aws.iot.dynamodbaction/payload-field (clojure.spec.alpha/and :portkey.aws.iot/payload-field))
(clojure.spec.alpha/def :portkey.aws.iot.dynamodbaction/hash-key-field (clojure.spec.alpha/and :portkey.aws.iot/hash-key-field))
(clojure.spec.alpha/def :portkey.aws.iot.dynamodbaction/range-key-type (clojure.spec.alpha/and :portkey.aws.iot/dynamo-key-type))
(clojure.spec.alpha/def :portkey.aws.iot/dynamodbaction (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.dynamodbaction/tableName :portkey.aws.iot.dynamodbaction/roleArn :portkey.aws.iot.dynamodbaction/hashKeyField :portkey.aws.iot.dynamodbaction/hashKeyValue] :opt-un [:portkey.aws.iot.dynamodbaction/rangeKeyValue :portkey.aws.iot.dynamodbaction/rangeKeyField :portkey.aws.iot.dynamodbaction/hashKeyType :portkey.aws.iot.dynamodbaction/operation :portkey.aws.iot.dynamodbaction/payloadField :portkey.aws.iot.dynamodbaction/rangeKeyType]))

(clojure.spec.alpha/def :portkey.aws.iot/delete-thing-response (portkey.awsgen/json-keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.list-policy-principals-response/principals (clojure.spec.alpha/and :portkey.aws.iot/principals))
(clojure.spec.alpha/def :portkey.aws.iot.list-policy-principals-response/next-marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot/list-policy-principals-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.list-policy-principals-response/principals :portkey.aws.iot.list-policy-principals-response/nextMarker]))

(clojure.spec.alpha/def :portkey.aws.iot/topic-rule-list (clojure.spec.alpha/coll-of :portkey.aws.iot/topic-rule-list-item :max-count nil))

(clojure.spec.alpha/def :portkey.aws.iot.update-thing-request/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.update-thing-request/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.update-thing-request/attribute-payload (clojure.spec.alpha/and :portkey.aws.iot/attribute-payload))
(clojure.spec.alpha/def :portkey.aws.iot.update-thing-request/expected-version (clojure.spec.alpha/and :portkey.aws.iot/optional-version))
(clojure.spec.alpha/def :portkey.aws.iot.update-thing-request/remove-thing-type (clojure.spec.alpha/and :portkey.aws.iot/remove-thing-type))
(clojure.spec.alpha/def :portkey.aws.iot/update-thing-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.update-thing-request/thingName] :opt-un [:portkey.aws.iot.update-thing-request/thingTypeName :portkey.aws.iot.update-thing-request/attributePayload :portkey.aws.iot.update-thing-request/expectedVersion :portkey.aws.iot.update-thing-request/removeThingType]))

(clojure.spec.alpha/def :portkey.aws.iot/policy-version-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__56603__auto__] (clojure.core/re-matches #"[0-9]+" s__56603__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.list-thing-types-response/thing-types (clojure.spec.alpha/and :portkey.aws.iot/thing-type-list))
(clojure.spec.alpha/def :portkey.aws.iot.list-thing-types-response/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-thing-types-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.list-thing-types-response/thingTypes :portkey.aws.iot.list-thing-types-response/nextToken]))

(clojure.spec.alpha/def :portkey.aws.iot.describecacertificate-request/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot/describecacertificate-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.describecacertificate-request/certificateId] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/dynamo-operation (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.create-thing-response/thing-name (clojure.spec.alpha/and :portkey.aws.iot/thing-name))
(clojure.spec.alpha/def :portkey.aws.iot.create-thing-response/thing-arn (clojure.spec.alpha/and :portkey.aws.iot/thing-arn))
(clojure.spec.alpha/def :portkey.aws.iot/create-thing-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.create-thing-response/thingName :portkey.aws.iot.create-thing-response/thingArn]))

(clojure.spec.alpha/def :portkey.aws.iot.list-policy-principals-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.list-policy-principals-request/marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot.list-policy-principals-request/page-size (clojure.spec.alpha/and :portkey.aws.iot/page-size))
(clojure.spec.alpha/def :portkey.aws.iot.list-policy-principals-request/ascending-order (clojure.spec.alpha/and :portkey.aws.iot/ascending-order))
(clojure.spec.alpha/def :portkey.aws.iot/list-policy-principals-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.list-policy-principals-request/policyName] :opt-un [:portkey.aws.iot.list-policy-principals-request/marker :portkey.aws.iot.list-policy-principals-request/pageSize :portkey.aws.iot.list-policy-principals-request/ascendingOrder]))

(clojure.spec.alpha/def :portkey.aws.iot/certificate-status (clojure.spec.alpha/conformer (clojure.core/let [m__56599__auto__ {:inactive "INACTIVE", "REGISTER_INACTIVE" "REGISTER_INACTIVE", "REVOKED" "REVOKED", :revoked "REVOKED", :pending-activation "PENDING_ACTIVATION", :register-inactive "REGISTER_INACTIVE", :pending-transfer "PENDING_TRANSFER", :active "ACTIVE", "INACTIVE" "INACTIVE", "PENDING_ACTIVATION" "PENDING_ACTIVATION", "ACTIVE" "ACTIVE", "PENDING_TRANSFER" "PENDING_TRANSFER"}] (clojure.core/fn [s__56600__auto__] (m__56599__auto__ s__56600__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.awsgen/dashed)))

(clojure.spec.alpha/def :portkey.aws.iot.policy/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.policy/policy-arn (clojure.spec.alpha/and :portkey.aws.iot/policy-arn))
(clojure.spec.alpha/def :portkey.aws.iot/policy (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.policy/policyName :portkey.aws.iot.policy/policyArn]))

(clojure.spec.alpha/def :portkey.aws.iot/key-pair (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot/PublicKey :portkey.aws.iot/PrivateKey]))

(clojure.spec.alpha/def :portkey.aws.iot/max-results (clojure.spec.alpha/and clojure.core/int? (fn* [p1__56642__56643__auto__] (clojure.core/<= 1 p1__56642__56643__auto__)) (fn* [p1__56644__56645__auto__] (clojure.core/<= p1__56644__56645__auto__ 10000))))

(clojure.spec.alpha/def :portkey.aws.iot.malformed-policy-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/malformed-policy-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.malformed-policy-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot/set-as-default clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot/version clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot.registercacertificate-response/certificate-arn (clojure.spec.alpha/and :portkey.aws.iot/certificate-arn))
(clojure.spec.alpha/def :portkey.aws.iot.registercacertificate-response/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot/registercacertificate-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.registercacertificate-response/certificateArn :portkey.aws.iot.registercacertificate-response/certificateId]))

(clojure.spec.alpha/def :portkey.aws.iot/metric-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.logging-options-payload/role-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.logging-options-payload/log-level (clojure.spec.alpha/and :portkey.aws.iot/log-level))
(clojure.spec.alpha/def :portkey.aws.iot/logging-options-payload (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.logging-options-payload/roleArn] :opt-un [:portkey.aws.iot.logging-options-payload/logLevel]))

(clojure.spec.alpha/def :portkey.aws.iot/elasticsearch-id (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.throttling-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/throttling-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.throttling-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot/resource-arn (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.salesforce-action/token (clojure.spec.alpha/and :portkey.aws.iot/salesforce-token))
(clojure.spec.alpha/def :portkey.aws.iot.salesforce-action/url (clojure.spec.alpha/and :portkey.aws.iot/salesforce-endpoint))
(clojure.spec.alpha/def :portkey.aws.iot/salesforce-action (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.salesforce-action/token :portkey.aws.iot.salesforce-action/url] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/salesforce-endpoint (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__56602__auto__] (clojure.core/< (clojure.core/count s__56602__auto__) 2000)) (clojure.core/fn [s__56603__auto__] (clojure.core/re-matches #"https://ingestion-[a-zA-Z0-9]{1,12}\.[a-zA-Z0-9]+\.((sfdc-matrix\.net)|(sfdcnow\.com))/streams/\w{1,20}/\w{1,20}/event" s__56603__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot/metric-namespace (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.list-policies-response/policies (clojure.spec.alpha/and :portkey.aws.iot/policies))
(clojure.spec.alpha/def :portkey.aws.iot.list-policies-response/next-marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot/list-policies-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.list-policies-response/policies :portkey.aws.iot.list-policies-response/nextMarker]))

(clojure.spec.alpha/def :portkey.aws.iot/ascending-order clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot/is-default-version clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.transfer-conflict-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/transfer-conflict-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.transfer-conflict-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot/optional-version clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.iot/principal (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.cacertificate-description/certificate-arn (clojure.spec.alpha/and :portkey.aws.iot/certificate-arn))
(clojure.spec.alpha/def :portkey.aws.iot.cacertificate-description/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.cacertificate-description/status (clojure.spec.alpha/and :portkey.aws.iot/cacertificate-status))
(clojure.spec.alpha/def :portkey.aws.iot.cacertificate-description/certificate-pem (clojure.spec.alpha/and :portkey.aws.iot/certificate-pem))
(clojure.spec.alpha/def :portkey.aws.iot.cacertificate-description/owned-by (clojure.spec.alpha/and :portkey.aws.iot/aws-account-id))
(clojure.spec.alpha/def :portkey.aws.iot.cacertificate-description/creation-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.cacertificate-description/auto-registration-status (clojure.spec.alpha/and :portkey.aws.iot/auto-registration-status))
(clojure.spec.alpha/def :portkey.aws.iot/cacertificate-description (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.cacertificate-description/certificateArn :portkey.aws.iot.cacertificate-description/certificateId :portkey.aws.iot.cacertificate-description/status :portkey.aws.iot.cacertificate-description/certificatePem :portkey.aws.iot.cacertificate-description/ownedBy :portkey.aws.iot.cacertificate-description/creationDate :portkey.aws.iot.cacertificate-description/autoRegistrationStatus]))

(clojure.spec.alpha/def :portkey.aws.iot.transfer-data/transfer-message (clojure.spec.alpha/and :portkey.aws.iot/message))
(clojure.spec.alpha/def :portkey.aws.iot.transfer-data/reject-reason (clojure.spec.alpha/and :portkey.aws.iot/message))
(clojure.spec.alpha/def :portkey.aws.iot.transfer-data/transfer-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.transfer-data/accept-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot.transfer-data/reject-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot/transfer-data (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.transfer-data/transferMessage :portkey.aws.iot.transfer-data/rejectReason :portkey.aws.iot.transfer-data/transferDate :portkey.aws.iot.transfer-data/acceptDate :portkey.aws.iot.transfer-data/rejectDate]))

(clojure.spec.alpha/def :portkey.aws.iot.registration-code-validation-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/registration-code-validation-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.registration-code-validation-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot/policy-versions (clojure.spec.alpha/coll-of :portkey.aws.iot/policy-version :max-count nil))

(clojure.spec.alpha/def :portkey.aws.iot.cloudwatch-alarm-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.cloudwatch-alarm-action/alarm-name (clojure.spec.alpha/and :portkey.aws.iot/alarm-name))
(clojure.spec.alpha/def :portkey.aws.iot.cloudwatch-alarm-action/state-reason (clojure.spec.alpha/and :portkey.aws.iot/state-reason))
(clojure.spec.alpha/def :portkey.aws.iot.cloudwatch-alarm-action/state-value (clojure.spec.alpha/and :portkey.aws.iot/state-value))
(clojure.spec.alpha/def :portkey.aws.iot/cloudwatch-alarm-action (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.cloudwatch-alarm-action/roleArn :portkey.aws.iot.cloudwatch-alarm-action/alarmName :portkey.aws.iot.cloudwatch-alarm-action/stateReason :portkey.aws.iot.cloudwatch-alarm-action/stateValue] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.lambda-action/function-arn (clojure.spec.alpha/and :portkey.aws.iot/function-arn))
(clojure.spec.alpha/def :portkey.aws.iot/lambda-action (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.lambda-action/functionArn] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.set-logging-options-request/logging-options-payload (clojure.spec.alpha/and :portkey.aws.iot/logging-options-payload))
(clojure.spec.alpha/def :portkey.aws.iot/set-logging-options-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.set-logging-options-request/loggingOptionsPayload] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/bucket-name (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/certificate-id (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__56601__auto__] (clojure.core/<= 64 (clojure.core/count s__56601__auto__))) (clojure.core/fn [s__56602__auto__] (clojure.core/< (clojure.core/count s__56602__auto__) 64)) (clojure.core/fn [s__56603__auto__] (clojure.core/re-matches #"(0x)?[a-fA-F0-9]+" s__56603__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot/attach-thing-principal-response (portkey.awsgen/json-keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/endpoint-address (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/certificate-pem (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__56601__auto__] (clojure.core/<= 1 (clojure.core/count s__56601__auto__))) (clojure.core/fn [s__56602__auto__] (clojure.core/< (clojure.core/count s__56602__auto__) 65536))))

(clojure.spec.alpha/def :portkey.aws.iot.create-thing-type-request/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.create-thing-type-request/thing-type-properties (clojure.spec.alpha/and :portkey.aws.iot/thing-type-properties))
(clojure.spec.alpha/def :portkey.aws.iot/create-thing-type-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.create-thing-type-request/thingTypeName] :opt-un [:portkey.aws.iot.create-thing-type-request/thingTypeProperties]))

(clojure.spec.alpha/def :portkey.aws.iot.action/dynamodb (clojure.spec.alpha/and :portkey.aws.iot/dynamodbaction))
(clojure.spec.alpha/def :portkey.aws.iot.action/sns (clojure.spec.alpha/and :portkey.aws.iot/sns-action))
(clojure.spec.alpha/def :portkey.aws.iot.action/cloudwatch-alarm (clojure.spec.alpha/and :portkey.aws.iot/cloudwatch-alarm-action))
(clojure.spec.alpha/def :portkey.aws.iot.action/republish (clojure.spec.alpha/and :portkey.aws.iot/republish-action))
(clojure.spec.alpha/def :portkey.aws.iot.action/kinesis (clojure.spec.alpha/and :portkey.aws.iot/kinesis-action))
(clojure.spec.alpha/def :portkey.aws.iot.action/s3 (clojure.spec.alpha/and :portkey.aws.iot/s3-action))
(clojure.spec.alpha/def :portkey.aws.iot.action/salesforce (clojure.spec.alpha/and :portkey.aws.iot/salesforce-action))
(clojure.spec.alpha/def :portkey.aws.iot.action/sqs (clojure.spec.alpha/and :portkey.aws.iot/sqs-action))
(clojure.spec.alpha/def :portkey.aws.iot.action/elasticsearch (clojure.spec.alpha/and :portkey.aws.iot/elasticsearch-action))
(clojure.spec.alpha/def :portkey.aws.iot.action/cloudwatch-metric (clojure.spec.alpha/and :portkey.aws.iot/cloudwatch-metric-action))
(clojure.spec.alpha/def :portkey.aws.iot.action/firehose (clojure.spec.alpha/and :portkey.aws.iot/firehose-action))
(clojure.spec.alpha/def :portkey.aws.iot.action/dynamodbv2 (clojure.spec.alpha/and :portkey.aws.iot/dynamodbv2-action))
(clojure.spec.alpha/def :portkey.aws.iot.action/lambda (clojure.spec.alpha/and :portkey.aws.iot/lambda-action))
(clojure.spec.alpha/def :portkey.aws.iot/action (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.action/dynamoDB :portkey.aws.iot.action/sns :portkey.aws.iot.action/cloudwatchAlarm :portkey.aws.iot.action/republish :portkey.aws.iot.action/kinesis :portkey.aws.iot.action/s3 :portkey.aws.iot.action/salesforce :portkey.aws.iot.action/sqs :portkey.aws.iot.action/elasticsearch :portkey.aws.iot.action/cloudwatchMetric :portkey.aws.iot.action/firehose :portkey.aws.iot.action/dynamoDBv2 :portkey.aws.iot.action/lambda]))

(clojure.spec.alpha/def :portkey.aws.iot/thing-type-list (clojure.spec.alpha/coll-of :portkey.aws.iot/thing-type-definition :max-count nil))

(clojure.spec.alpha/def :portkey.aws.iot.create-topic-rule-request/rule-name (clojure.spec.alpha/and :portkey.aws.iot/rule-name))
(clojure.spec.alpha/def :portkey.aws.iot.create-topic-rule-request/topic-rule-payload (clojure.spec.alpha/and :portkey.aws.iot/topic-rule-payload))
(clojure.spec.alpha/def :portkey.aws.iot/create-topic-rule-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.create-topic-rule-request/ruleName :portkey.aws.iot.create-topic-rule-request/topicRulePayload] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot/created-at-date clojure.core/inst?)

(clojure.spec.alpha/def :portkey.aws.iot.certificate/certificate-arn (clojure.spec.alpha/and :portkey.aws.iot/certificate-arn))
(clojure.spec.alpha/def :portkey.aws.iot.certificate/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.certificate/status (clojure.spec.alpha/and :portkey.aws.iot/certificate-status))
(clojure.spec.alpha/def :portkey.aws.iot.certificate/creation-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot/certificate (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.certificate/certificateArn :portkey.aws.iot.certificate/certificateId :portkey.aws.iot.certificate/status :portkey.aws.iot.certificate/creationDate]))

(clojure.spec.alpha/def :portkey.aws.iot.create-policy-version-response/policy-arn (clojure.spec.alpha/and :portkey.aws.iot/policy-arn))
(clojure.spec.alpha/def :portkey.aws.iot.create-policy-version-response/policy-document (clojure.spec.alpha/and :portkey.aws.iot/policy-document))
(clojure.spec.alpha/def :portkey.aws.iot.create-policy-version-response/policy-version-id (clojure.spec.alpha/and :portkey.aws.iot/policy-version-id))
(clojure.spec.alpha/def :portkey.aws.iot.create-policy-version-response/is-default-version (clojure.spec.alpha/and :portkey.aws.iot/is-default-version))
(clojure.spec.alpha/def :portkey.aws.iot/create-policy-version-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.create-policy-version-response/policyArn :portkey.aws.iot.create-policy-version-response/policyDocument :portkey.aws.iot.create-policy-version-response/policyVersionId :portkey.aws.iot.create-policy-version-response/isDefaultVersion]))

(clojure.spec.alpha/def :portkey.aws.iot/state-reason (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot/elasticsearch-endpoint (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__56603__auto__] (clojure.core/re-matches #"https?://.*" s__56603__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot.list-things-request/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot.list-things-request/max-results (clojure.spec.alpha/and :portkey.aws.iot/registry-max-results))
(clojure.spec.alpha/def :portkey.aws.iot.list-things-request/attribute-name (clojure.spec.alpha/and :portkey.aws.iot/attribute-name))
(clojure.spec.alpha/def :portkey.aws.iot.list-things-request/attribute-value (clojure.spec.alpha/and :portkey.aws.iot/attribute-value))
(clojure.spec.alpha/def :portkey.aws.iot.list-things-request/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot/list-things-request (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.list-things-request/nextToken :portkey.aws.iot.list-things-request/maxResults :portkey.aws.iot.list-things-request/attributeName :portkey.aws.iot.list-things-request/attributeValue :portkey.aws.iot.list-things-request/thingTypeName]))

(clojure.spec.alpha/def :portkey.aws.iot.describe-endpoint-response/endpoint-address (clojure.spec.alpha/and :portkey.aws.iot/endpoint-address))
(clojure.spec.alpha/def :portkey.aws.iot/describe-endpoint-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.describe-endpoint-response/endpointAddress]))

(clojure.spec.alpha/def :portkey.aws.iot.replace-topic-rule-request/rule-name (clojure.spec.alpha/and :portkey.aws.iot/rule-name))
(clojure.spec.alpha/def :portkey.aws.iot.replace-topic-rule-request/topic-rule-payload (clojure.spec.alpha/and :portkey.aws.iot/topic-rule-payload))
(clojure.spec.alpha/def :portkey.aws.iot/replace-topic-rule-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.replace-topic-rule-request/ruleName :portkey.aws.iot.replace-topic-rule-request/topicRulePayload] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.s3-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.s3-action/bucket-name (clojure.spec.alpha/and :portkey.aws.iot/bucket-name))
(clojure.spec.alpha/def :portkey.aws.iot.s3-action/key (clojure.spec.alpha/and :portkey.aws.iot/key))
(clojure.spec.alpha/def :portkey.aws.iot.s3-action/canned-acl (clojure.spec.alpha/and :portkey.aws.iot/canned-access-control-list))
(clojure.spec.alpha/def :portkey.aws.iot/s3-action (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.s3-action/roleArn :portkey.aws.iot.s3-action/bucketName :portkey.aws.iot.s3-action/key] :opt-un [:portkey.aws.iot.s3-action/cannedAcl]))

(clojure.spec.alpha/def :portkey.aws.iot/get-registration-code-request (portkey.awsgen/json-keys :req-un [] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.iot.kinesis-action/role-arn (clojure.spec.alpha/and :portkey.aws.iot/aws-arn))
(clojure.spec.alpha/def :portkey.aws.iot.kinesis-action/stream-name (clojure.spec.alpha/and :portkey.aws.iot/stream-name))
(clojure.spec.alpha/def :portkey.aws.iot.kinesis-action/partition-key (clojure.spec.alpha/and :portkey.aws.iot/partition-key))
(clojure.spec.alpha/def :portkey.aws.iot/kinesis-action (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.kinesis-action/roleArn :portkey.aws.iot.kinesis-action/streamName] :opt-un [:portkey.aws.iot.kinesis-action/partitionKey]))

(clojure.spec.alpha/def :portkey.aws.iot.cacertificate/certificate-arn (clojure.spec.alpha/and :portkey.aws.iot/certificate-arn))
(clojure.spec.alpha/def :portkey.aws.iot.cacertificate/certificate-id (clojure.spec.alpha/and :portkey.aws.iot/certificate-id))
(clojure.spec.alpha/def :portkey.aws.iot.cacertificate/status (clojure.spec.alpha/and :portkey.aws.iot/cacertificate-status))
(clojure.spec.alpha/def :portkey.aws.iot.cacertificate/creation-date (clojure.spec.alpha/and :portkey.aws.iot/date-type))
(clojure.spec.alpha/def :portkey.aws.iot/cacertificate (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.cacertificate/certificateArn :portkey.aws.iot.cacertificate/certificateId :portkey.aws.iot.cacertificate/status :portkey.aws.iot.cacertificate/creationDate]))

(clojure.spec.alpha/def :portkey.aws.iot/public-key (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__56601__auto__] (clojure.core/<= 1 (clojure.core/count s__56601__auto__)))))

(clojure.spec.alpha/def :portkey.aws.iot.list-things-response/things (clojure.spec.alpha/and :portkey.aws.iot/thing-attribute-list))
(clojure.spec.alpha/def :portkey.aws.iot.list-things-response/next-token (clojure.spec.alpha/and :portkey.aws.iot/next-token))
(clojure.spec.alpha/def :portkey.aws.iot/list-things-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.list-things-response/things :portkey.aws.iot.list-things-response/nextToken]))

(clojure.spec.alpha/def :portkey.aws.iot.create-policy-version-request/policy-name (clojure.spec.alpha/and :portkey.aws.iot/policy-name))
(clojure.spec.alpha/def :portkey.aws.iot.create-policy-version-request/policy-document (clojure.spec.alpha/and :portkey.aws.iot/policy-document))
(clojure.spec.alpha/def :portkey.aws.iot.create-policy-version-request/set-as-default (clojure.spec.alpha/and :portkey.aws.iot/set-as-default))
(clojure.spec.alpha/def :portkey.aws.iot/create-policy-version-request (portkey.awsgen/json-keys :req-un [:portkey.aws.iot.create-policy-version-request/policyName :portkey.aws.iot.create-policy-version-request/policyDocument] :opt-un [:portkey.aws.iot.create-policy-version-request/setAsDefault]))

(clojure.spec.alpha/def :portkey.aws.iot.create-thing-type-response/thing-type-name (clojure.spec.alpha/and :portkey.aws.iot/thing-type-name))
(clojure.spec.alpha/def :portkey.aws.iot.create-thing-type-response/thing-type-arn (clojure.spec.alpha/and :portkey.aws.iot/thing-type-arn))
(clojure.spec.alpha/def :portkey.aws.iot/create-thing-type-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.create-thing-type-response/thingTypeName :portkey.aws.iot.create-thing-type-response/thingTypeArn]))

(clojure.spec.alpha/def :portkey.aws.iot.certificate-conflict-exception/message (clojure.spec.alpha/and :portkey.aws.iot/error-message))
(clojure.spec.alpha/def :portkey.aws.iot/certificate-conflict-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.certificate-conflict-exception/message]))

(clojure.spec.alpha/def :portkey.aws.iot.list-outgoing-certificates-response/outgoing-certificates (clojure.spec.alpha/and :portkey.aws.iot/outgoing-certificates))
(clojure.spec.alpha/def :portkey.aws.iot.list-outgoing-certificates-response/next-marker (clojure.spec.alpha/and :portkey.aws.iot/marker))
(clojure.spec.alpha/def :portkey.aws.iot/list-outgoing-certificates-response (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.list-outgoing-certificates-response/outgoingCertificates :portkey.aws.iot.list-outgoing-certificates-response/nextMarker]))

(clojure.spec.alpha/def :portkey.aws.iot/payload-field (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.iot.topic-rule-list-item/rule-arn (clojure.spec.alpha/and :portkey.aws.iot/rule-arn))
(clojure.spec.alpha/def :portkey.aws.iot.topic-rule-list-item/rule-name (clojure.spec.alpha/and :portkey.aws.iot/rule-name))
(clojure.spec.alpha/def :portkey.aws.iot.topic-rule-list-item/topic-pattern (clojure.spec.alpha/and :portkey.aws.iot/topic-pattern))
(clojure.spec.alpha/def :portkey.aws.iot.topic-rule-list-item/created-at (clojure.spec.alpha/and :portkey.aws.iot/created-at-date))
(clojure.spec.alpha/def :portkey.aws.iot.topic-rule-list-item/rule-disabled (clojure.spec.alpha/and :portkey.aws.iot/is-disabled))
(clojure.spec.alpha/def :portkey.aws.iot/topic-rule-list-item (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.topic-rule-list-item/ruleArn :portkey.aws.iot.topic-rule-list-item/ruleName :portkey.aws.iot.topic-rule-list-item/topicPattern :portkey.aws.iot.topic-rule-list-item/createdAt :portkey.aws.iot.topic-rule-list-item/ruleDisabled]))

(clojure.spec.alpha/def :portkey.aws.iot/firehose-separator (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__56603__auto__] (clojure.core/re-matches #"([\n\t])|(\r\n)|(,)" s__56603__auto__))))

(clojure.spec.alpha/def :portkey.aws.iot/principals (clojure.spec.alpha/coll-of :portkey.aws.iot/principal-arn :max-count nil))

(clojure.spec.alpha/def :portkey.aws.iot/boolean clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.iot.topic-rule/rule-name (clojure.spec.alpha/and :portkey.aws.iot/rule-name))
(clojure.spec.alpha/def :portkey.aws.iot.topic-rule/sql (clojure.spec.alpha/and :portkey.aws.iot/sql))
(clojure.spec.alpha/def :portkey.aws.iot.topic-rule/description (clojure.spec.alpha/and :portkey.aws.iot/description))
(clojure.spec.alpha/def :portkey.aws.iot.topic-rule/created-at (clojure.spec.alpha/and :portkey.aws.iot/created-at-date))
(clojure.spec.alpha/def :portkey.aws.iot.topic-rule/actions (clojure.spec.alpha/and :portkey.aws.iot/action-list))
(clojure.spec.alpha/def :portkey.aws.iot.topic-rule/rule-disabled (clojure.spec.alpha/and :portkey.aws.iot/is-disabled))
(clojure.spec.alpha/def :portkey.aws.iot.topic-rule/aws-iot-sql-version (clojure.spec.alpha/and :portkey.aws.iot/aws-iot-sql-version))
(clojure.spec.alpha/def :portkey.aws.iot/topic-rule (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.iot.topic-rule/ruleName :portkey.aws.iot.topic-rule/sql :portkey.aws.iot.topic-rule/description :portkey.aws.iot.topic-rule/createdAt :portkey.aws.iot.topic-rule/actions :portkey.aws.iot.topic-rule/ruleDisabled :portkey.aws.iot.topic-rule/awsIotSqlVersion]))

(clojure.spec.alpha/def :portkey.aws.iot/registration-code (clojure.spec.alpha/and clojure.core/string? (clojure.core/fn [s__56601__auto__] (clojure.core/<= 64 (clojure.core/count s__56601__auto__))) (clojure.core/fn [s__56602__auto__] (clojure.core/< (clojure.core/count s__56602__auto__) 64)) (clojure.core/fn [s__56603__auto__] (clojure.core/re-matches #"(0x)?[a-fA-F0-9]+" s__56603__auto__))))

(clojure.core/defn list-policy-versions ([input__56767__auto__] (list-policy-versions input__56767__auto__ portkey.aws/*http-client*)) ([input58500 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/policies/{policyName}/version"), :body (clojure.spec.alpha/unform :portkey.aws.iot/ListPolicyVersionsRequest input58500)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"policyName" "policyName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58499] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58499)) (clojure.spec.alpha/unform :portkey.aws.iot/list-policy-versions-response (:body response58499)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58499 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58499)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58499})))))))))))

(clojure.core/defn delete-policy-version ([input__56767__auto__] (delete-policy-version input__56767__auto__ portkey.aws/*http-client*)) ([input58502 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "DELETE", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/policies/{policyName}/version/{policyVersionId}"), :body (clojure.spec.alpha/unform :portkey.aws.iot/DeletePolicyVersionRequest input58502)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"policyName" "policyName", "policyVersionId" "policyVersionId"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58501] (clojure.core/let [errors__56772__auto__ {"DeleteConflictException" :portkey.aws.iot/delete-conflict-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58501)) true (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58501 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58501)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58501})))))))))))

(clojure.core/defn attach-principal-policy ([input__56767__auto__] (attach-principal-policy input__56767__auto__ portkey.aws/*http-client*)) ([input58504 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "PUT", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/principal-policies/{policyName}"), :body (clojure.spec.alpha/unform :portkey.aws.iot/AttachPrincipalPolicyRequest input58504)} (portkey.awsgen/params-to-header {"principal" ["x-amzn-iot-principal" nil]}) (portkey.awsgen/params-to-uri {"policyName" "policyName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58503] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "LimitExceededException" :portkey.aws.iot/limit-exceeded-exception}] (if (clojure.core/= nil (:status response58503)) true (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58503 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58503)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58503})))))))))))

(clojure.core/defn list-certificates-byca ([input__56767__auto__] (list-certificates-byca input__56767__auto__ portkey.aws/*http-client*)) ([input58506 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/certificates-by-ca/{caCertificateId}"), :body (clojure.spec.alpha/unform :portkey.aws.iot/ListCertificatesByCARequest input58506)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"caCertificateId" "caCertificateId"}) (portkey.awsgen/params-to-querystring {"pageSize" "pageSize", "marker" "marker", "isAscendingOrder" "ascendingOrder"}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58505] (clojure.core/let [errors__56772__auto__ {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58505)) (clojure.spec.alpha/unform :portkey.aws.iot/list-certificates-bycaresponse (:body response58505)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58505 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58505)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58505})))))))))))

(clojure.core/defn get-policy-version ([input__56767__auto__] (get-policy-version input__56767__auto__ portkey.aws/*http-client*)) ([input58508 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/policies/{policyName}/version/{policyVersionId}"), :body (clojure.spec.alpha/unform :portkey.aws.iot/GetPolicyVersionRequest input58508)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"policyName" "policyName", "policyVersionId" "policyVersionId"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58507] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58507)) (clojure.spec.alpha/unform :portkey.aws.iot/get-policy-version-response (:body response58507)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58507 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58507)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58507})))))))))))

(clojure.core/defn cancel-certificate-transfer ([input__56767__auto__] (cancel-certificate-transfer input__56767__auto__ portkey.aws/*http-client*)) ([input58510 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "PATCH", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/cancel-certificate-transfer/{certificateId}"), :body (clojure.spec.alpha/unform :portkey.aws.iot/CancelCertificateTransferRequest input58510)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"certificateId" "certificateId"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58509] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "TransferAlreadyCompletedException" :portkey.aws.iot/transfer-already-completed-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58509)) true (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58509 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58509)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58509})))))))))))

(clojure.core/defn listcacertificates ([input__56767__auto__] (listcacertificates input__56767__auto__ portkey.aws/*http-client*)) ([input58512 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/cacertificates"), :body (clojure.spec.alpha/unform :portkey.aws.iot/ListCACertificatesRequest input58512)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {}) (portkey.awsgen/params-to-querystring {"pageSize" "pageSize", "marker" "marker", "isAscendingOrder" "ascendingOrder"}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58511] (clojure.core/let [errors__56772__auto__ {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58511)) (clojure.spec.alpha/unform :portkey.aws.iot/listcacertificates-response (:body response58511)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58511 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58511)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58511})))))))))))

(clojure.core/defn create-thing ([input__56767__auto__] (create-thing input__56767__auto__ portkey.aws/*http-client*)) ([input58514 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "POST", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/things/{thingName}"), :body (clojure.spec.alpha/unform :portkey.aws.iot/CreateThingRequest input58514)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"thingName" "thingName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58513] (clojure.core/let [errors__56772__auto__ {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceAlreadyExistsException" :portkey.aws.iot/resource-already-exists-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}] (if (clojure.core/= nil (:status response58513)) (clojure.spec.alpha/unform :portkey.aws.iot/create-thing-response (:body response58513)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58513 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58513)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58513})))))))))))

(clojure.core/defn create-topic-rule ([input__56767__auto__] (create-topic-rule input__56767__auto__ portkey.aws/*http-client*)) ([input58516 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "POST", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/rules/{ruleName}"), :body (clojure.spec.alpha/unform :portkey.aws.iot/CreateTopicRuleRequest input58516)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"ruleName" "ruleName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload "topicRulePayload") (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58515] (clojure.core/let [errors__56772__auto__ {"SqlParseException" :portkey.aws.iot/sql-parse-exception, "InternalException" :portkey.aws.iot/internal-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ResourceAlreadyExistsException" :portkey.aws.iot/resource-already-exists-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception}] (if (clojure.core/= nil (:status response58515)) true (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58515 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58515)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58515})))))))))))

(clojure.core/defn accept-certificate-transfer ([input__56767__auto__] (accept-certificate-transfer input__56767__auto__ portkey.aws/*http-client*)) ([input58518 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "PATCH", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/accept-certificate-transfer/{certificateId}"), :body (clojure.spec.alpha/unform :portkey.aws.iot/AcceptCertificateTransferRequest input58518)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"certificateId" "certificateId"}) (portkey.awsgen/params-to-querystring {"setAsActive" "setAsActive"}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58517] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "TransferAlreadyCompletedException" :portkey.aws.iot/transfer-already-completed-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58517)) true (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58517 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58517)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58517})))))))))))

(clojure.core/defn get-registration-code ([input__56767__auto__] (get-registration-code input__56767__auto__ portkey.aws/*http-client*)) ([input58520 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/registrationcode"), :body (clojure.spec.alpha/unform :portkey.aws.iot/GetRegistrationCodeRequest input58520)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58519] (clojure.core/let [errors__56772__auto__ {"ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception}] (if (clojure.core/= nil (:status response58519)) (clojure.spec.alpha/unform :portkey.aws.iot/get-registration-code-response (:body response58519)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58519 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58519)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58519})))))))))))

(clojure.core/defn list-policies ([input__56767__auto__] (list-policies input__56767__auto__ portkey.aws/*http-client*)) ([input58522 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/policies"), :body (clojure.spec.alpha/unform :portkey.aws.iot/ListPoliciesRequest input58522)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {}) (portkey.awsgen/params-to-querystring {"marker" "marker", "pageSize" "pageSize", "isAscendingOrder" "ascendingOrder"}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58521] (clojure.core/let [errors__56772__auto__ {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58521)) (clojure.spec.alpha/unform :portkey.aws.iot/list-policies-response (:body response58521)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58521 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58521)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58521})))))))))))

(clojure.core/defn delete-registration-code ([input__56767__auto__] (delete-registration-code input__56767__auto__ portkey.aws/*http-client*)) ([input58524 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "DELETE", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/registrationcode"), :body (clojure.spec.alpha/unform :portkey.aws.iot/DeleteRegistrationCodeRequest input58524)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58523] (clojure.core/let [errors__56772__auto__ {"ThrottlingException" :portkey.aws.iot/throttling-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58523)) (clojure.spec.alpha/unform :portkey.aws.iot/delete-registration-code-response (:body response58523)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58523 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58523)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58523})))))))))))

(clojure.core/defn describecacertificate ([input__56767__auto__] (describecacertificate input__56767__auto__ portkey.aws/*http-client*)) ([input58526 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/cacertificate/{caCertificateId}"), :body (clojure.spec.alpha/unform :portkey.aws.iot/DescribeCACertificateRequest input58526)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"caCertificateId" "certificateId"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58525] (clojure.core/let [errors__56772__auto__ {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}] (if (clojure.core/= nil (:status response58525)) (clojure.spec.alpha/unform :portkey.aws.iot/describecacertificate-response (:body response58525)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58525 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58525)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58525})))))))))))

(clojure.core/defn detach-thing-principal ([input__56767__auto__] (detach-thing-principal input__56767__auto__ portkey.aws/*http-client*)) ([input58528 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "DELETE", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/things/{thingName}/principals"), :body (clojure.spec.alpha/unform :portkey.aws.iot/DetachThingPrincipalRequest input58528)} (portkey.awsgen/params-to-header {"principal" ["x-amzn-principal" nil]}) (portkey.awsgen/params-to-uri {"thingName" "thingName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58527] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58527)) (clojure.spec.alpha/unform :portkey.aws.iot/detach-thing-principal-response (:body response58527)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58527 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58527)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58527})))))))))))

(clojure.core/defn list-outgoing-certificates ([input__56767__auto__] (list-outgoing-certificates input__56767__auto__ portkey.aws/*http-client*)) ([input58530 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/certificates-out-going"), :body (clojure.spec.alpha/unform :portkey.aws.iot/ListOutgoingCertificatesRequest input58530)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {}) (portkey.awsgen/params-to-querystring {"pageSize" "pageSize", "marker" "marker", "isAscendingOrder" "ascendingOrder"}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58529] (clojure.core/let [errors__56772__auto__ {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58529)) (clojure.spec.alpha/unform :portkey.aws.iot/list-outgoing-certificates-response (:body response58529)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58529 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58529)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58529})))))))))))

(clojure.core/defn deletecacertificate ([input__56767__auto__] (deletecacertificate input__56767__auto__ portkey.aws/*http-client*)) ([input58532 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "DELETE", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/cacertificate/{caCertificateId}"), :body (clojure.spec.alpha/unform :portkey.aws.iot/DeleteCACertificateRequest input58532)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"caCertificateId" "certificateId"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58531] (clojure.core/let [errors__56772__auto__ {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "CertificateStateException" :portkey.aws.iot/certificate-state-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}] (if (clojure.core/= nil (:status response58531)) (clojure.spec.alpha/unform :portkey.aws.iot/deletecacertificate-response (:body response58531)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58531 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58531)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58531})))))))))))

(clojure.core/defn list-principal-things ([input__56767__auto__] (list-principal-things input__56767__auto__ portkey.aws/*http-client*)) ([input58534 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/principals/things"), :body (clojure.spec.alpha/unform :portkey.aws.iot/ListPrincipalThingsRequest input58534)} (portkey.awsgen/params-to-header {"principal" ["x-amzn-principal" nil]}) (portkey.awsgen/params-to-uri {}) (portkey.awsgen/params-to-querystring {"nextToken" "nextToken", "maxResults" "maxResults"}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58533] (clojure.core/let [errors__56772__auto__ {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}] (if (clojure.core/= nil (:status response58533)) (clojure.spec.alpha/unform :portkey.aws.iot/list-principal-things-response (:body response58533)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58533 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58533)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58533})))))))))))

(clojure.core/defn create-policy-version ([input__56767__auto__] (create-policy-version input__56767__auto__ portkey.aws/*http-client*)) ([input58536 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "POST", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/policies/{policyName}/version"), :body (clojure.spec.alpha/unform :portkey.aws.iot/CreatePolicyVersionRequest input58536)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"policyName" "policyName"}) (portkey.awsgen/params-to-querystring {"setAsDefault" "setAsDefault"}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58535] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "MalformedPolicyException" :portkey.aws.iot/malformed-policy-exception, "VersionsLimitExceededException" :portkey.aws.iot/versions-limit-exceeded-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58535)) (clojure.spec.alpha/unform :portkey.aws.iot/create-policy-version-response (:body response58535)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58535 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58535)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58535})))))))))))

(clojure.core/defn describe-endpoint ([input__56767__auto__] (describe-endpoint input__56767__auto__ portkey.aws/*http-client*)) ([input58538 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/endpoint"), :body (clojure.spec.alpha/unform :portkey.aws.iot/DescribeEndpointRequest input58538)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58537] (clojure.core/let [errors__56772__auto__ {"InternalFailureException" :portkey.aws.iot/internal-failure-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception}] (if (clojure.core/= nil (:status response58537)) (clojure.spec.alpha/unform :portkey.aws.iot/describe-endpoint-response (:body response58537)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58537 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58537)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58537})))))))))))

(clojure.core/defn register-certificate ([input__56767__auto__] (register-certificate input__56767__auto__ portkey.aws/*http-client*)) ([input58540 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "POST", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/certificate/register"), :body (clojure.spec.alpha/unform :portkey.aws.iot/RegisterCertificateRequest input58540)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {}) (portkey.awsgen/params-to-querystring {"setAsActive" "setAsActive"}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58539] (clojure.core/let [errors__56772__auto__ {"UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "CertificateStateException" :portkey.aws.iot/certificate-state-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "CertificateValidationException" :portkey.aws.iot/certificate-validation-exception, "ResourceAlreadyExistsException" :portkey.aws.iot/resource-already-exists-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "CertificateConflictException" :portkey.aws.iot/certificate-conflict-exception}] (if (clojure.core/= nil (:status response58539)) (clojure.spec.alpha/unform :portkey.aws.iot/register-certificate-response (:body response58539)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58539 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58539)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58539})))))))))))

(clojure.core/defn get-policy ([input__56767__auto__] (get-policy input__56767__auto__ portkey.aws/*http-client*)) ([input58542 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/policies/{policyName}"), :body (clojure.spec.alpha/unform :portkey.aws.iot/GetPolicyRequest input58542)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"policyName" "policyName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58541] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58541)) (clojure.spec.alpha/unform :portkey.aws.iot/get-policy-response (:body response58541)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58541 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58541)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58541})))))))))))

(clojure.core/defn enable-topic-rule ([input__56767__auto__] (enable-topic-rule input__56767__auto__ portkey.aws/*http-client*)) ([input58544 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "POST", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/rules/{ruleName}/enable"), :body (clojure.spec.alpha/unform :portkey.aws.iot/EnableTopicRuleRequest input58544)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"ruleName" "ruleName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58543] (clojure.core/let [errors__56772__auto__ {"InternalException" :portkey.aws.iot/internal-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception}] (if (clojure.core/= nil (:status response58543)) true (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58543 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58543)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58543})))))))))))

(clojure.core/defn deprecate-thing-type ([input__56767__auto__] (deprecate-thing-type input__56767__auto__ portkey.aws/*http-client*)) ([input58546 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "POST", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/thing-types/{thingTypeName}/deprecate"), :body (clojure.spec.alpha/unform :portkey.aws.iot/DeprecateThingTypeRequest input58546)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"thingTypeName" "thingTypeName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58545] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58545)) (clojure.spec.alpha/unform :portkey.aws.iot/deprecate-thing-type-response (:body response58545)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58545 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58545)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58545})))))))))))

(clojure.core/defn delete-thing-type ([input__56767__auto__] (delete-thing-type input__56767__auto__ portkey.aws/*http-client*)) ([input58548 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "DELETE", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/thing-types/{thingTypeName}"), :body (clojure.spec.alpha/unform :portkey.aws.iot/DeleteThingTypeRequest input58548)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"thingTypeName" "thingTypeName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58547] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58547)) (clojure.spec.alpha/unform :portkey.aws.iot/delete-thing-type-response (:body response58547)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58547 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58547)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58547})))))))))))

(clojure.core/defn replace-topic-rule ([input__56767__auto__] (replace-topic-rule input__56767__auto__ portkey.aws/*http-client*)) ([input58550 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "PATCH", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/rules/{ruleName}"), :body (clojure.spec.alpha/unform :portkey.aws.iot/ReplaceTopicRuleRequest input58550)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"ruleName" "ruleName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload "topicRulePayload") (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58549] (clojure.core/let [errors__56772__auto__ {"SqlParseException" :portkey.aws.iot/sql-parse-exception, "InternalException" :portkey.aws.iot/internal-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception}] (if (clojure.core/= nil (:status response58549)) true (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58549 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58549)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58549})))))))))))

(clojure.core/defn get-topic-rule ([input__56767__auto__] (get-topic-rule input__56767__auto__ portkey.aws/*http-client*)) ([input58552 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/rules/{ruleName}"), :body (clojure.spec.alpha/unform :portkey.aws.iot/GetTopicRuleRequest input58552)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"ruleName" "ruleName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58551] (clojure.core/let [errors__56772__auto__ {"InternalException" :portkey.aws.iot/internal-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception}] (if (clojure.core/= nil (:status response58551)) (clojure.spec.alpha/unform :portkey.aws.iot/get-topic-rule-response (:body response58551)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58551 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58551)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58551})))))))))))

(clojure.core/defn reject-certificate-transfer ([input__56767__auto__] (reject-certificate-transfer input__56767__auto__ portkey.aws/*http-client*)) ([input58554 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "PATCH", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/reject-certificate-transfer/{certificateId}"), :body (clojure.spec.alpha/unform :portkey.aws.iot/RejectCertificateTransferRequest input58554)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"certificateId" "certificateId"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58553] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "TransferAlreadyCompletedException" :portkey.aws.iot/transfer-already-completed-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58553)) true (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58553 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58553)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58553})))))))))))

(clojure.core/defn delete-thing ([input__56767__auto__] (delete-thing input__56767__auto__ portkey.aws/*http-client*)) ([input58556 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "DELETE", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/things/{thingName}"), :body (clojure.spec.alpha/unform :portkey.aws.iot/DeleteThingRequest input58556)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"thingName" "thingName"}) (portkey.awsgen/params-to-querystring {"expectedVersion" "expectedVersion"}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58555] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "VersionConflictException" :portkey.aws.iot/version-conflict-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58555)) (clojure.spec.alpha/unform :portkey.aws.iot/delete-thing-response (:body response58555)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58555 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58555)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58555})))))))))))

(clojure.core/defn list-certificates ([input__56767__auto__] (list-certificates input__56767__auto__ portkey.aws/*http-client*)) ([input58558 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/certificates"), :body (clojure.spec.alpha/unform :portkey.aws.iot/ListCertificatesRequest input58558)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {}) (portkey.awsgen/params-to-querystring {"pageSize" "pageSize", "marker" "marker", "isAscendingOrder" "ascendingOrder"}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58557] (clojure.core/let [errors__56772__auto__ {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58557)) (clojure.spec.alpha/unform :portkey.aws.iot/list-certificates-response (:body response58557)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58557 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58557)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58557})))))))))))

(clojure.core/defn list-thing-types ([input__56767__auto__] (list-thing-types input__56767__auto__ portkey.aws/*http-client*)) ([input58560 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/thing-types"), :body (clojure.spec.alpha/unform :portkey.aws.iot/ListThingTypesRequest input58560)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {}) (portkey.awsgen/params-to-querystring {"nextToken" "nextToken", "maxResults" "maxResults", "thingTypeName" "thingTypeName"}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58559] (clojure.core/let [errors__56772__auto__ {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58559)) (clojure.spec.alpha/unform :portkey.aws.iot/list-thing-types-response (:body response58559)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58559 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58559)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58559})))))))))))

(clojure.core/defn describe-thing ([input__56767__auto__] (describe-thing input__56767__auto__ portkey.aws/*http-client*)) ([input58562 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/things/{thingName}"), :body (clojure.spec.alpha/unform :portkey.aws.iot/DescribeThingRequest input58562)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"thingName" "thingName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58561] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58561)) (clojure.spec.alpha/unform :portkey.aws.iot/describe-thing-response (:body response58561)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58561 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58561)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58561})))))))))))

(clojure.core/defn list-policy-principals ([input__56767__auto__] (list-policy-principals input__56767__auto__ portkey.aws/*http-client*)) ([input58564 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/policy-principals"), :body (clojure.spec.alpha/unform :portkey.aws.iot/ListPolicyPrincipalsRequest input58564)} (portkey.awsgen/params-to-header {"policyName" ["x-amzn-iot-policy" nil]}) (portkey.awsgen/params-to-uri {}) (portkey.awsgen/params-to-querystring {"marker" "marker", "pageSize" "pageSize", "isAscendingOrder" "ascendingOrder"}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58563] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58563)) (clojure.spec.alpha/unform :portkey.aws.iot/list-policy-principals-response (:body response58563)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58563 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58563)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58563})))))))))))

(clojure.core/defn set-default-policy-version ([input__56767__auto__] (set-default-policy-version input__56767__auto__ portkey.aws/*http-client*)) ([input58566 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "PATCH", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/policies/{policyName}/version/{policyVersionId}"), :body (clojure.spec.alpha/unform :portkey.aws.iot/SetDefaultPolicyVersionRequest input58566)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"policyName" "policyName", "policyVersionId" "policyVersionId"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58565] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58565)) true (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58565 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58565)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58565})))))))))))

(clojure.core/defn create-policy ([input__56767__auto__] (create-policy input__56767__auto__ portkey.aws/*http-client*)) ([input58568 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "POST", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/policies/{policyName}"), :body (clojure.spec.alpha/unform :portkey.aws.iot/CreatePolicyRequest input58568)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"policyName" "policyName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58567] (clojure.core/let [errors__56772__auto__ {"ResourceAlreadyExistsException" :portkey.aws.iot/resource-already-exists-exception, "MalformedPolicyException" :portkey.aws.iot/malformed-policy-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58567)) (clojure.spec.alpha/unform :portkey.aws.iot/create-policy-response (:body response58567)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58567 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58567)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58567})))))))))))

(clojure.core/defn describe-thing-type ([input__56767__auto__] (describe-thing-type input__56767__auto__ portkey.aws/*http-client*)) ([input58570 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/thing-types/{thingTypeName}"), :body (clojure.spec.alpha/unform :portkey.aws.iot/DescribeThingTypeRequest input58570)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"thingTypeName" "thingTypeName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58569] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58569)) (clojure.spec.alpha/unform :portkey.aws.iot/describe-thing-type-response (:body response58569)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58569 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58569)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58569})))))))))))

(clojure.core/defn attach-thing-principal ([input__56767__auto__] (attach-thing-principal input__56767__auto__ portkey.aws/*http-client*)) ([input58572 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "PUT", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/things/{thingName}/principals"), :body (clojure.spec.alpha/unform :portkey.aws.iot/AttachThingPrincipalRequest input58572)} (portkey.awsgen/params-to-header {"principal" ["x-amzn-principal" nil]}) (portkey.awsgen/params-to-uri {"thingName" "thingName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58571] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58571)) (clojure.spec.alpha/unform :portkey.aws.iot/attach-thing-principal-response (:body response58571)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58571 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58571)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58571})))))))))))

(clojure.core/defn create-keys-and-certificate ([input__56767__auto__] (create-keys-and-certificate input__56767__auto__ portkey.aws/*http-client*)) ([input58574 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "POST", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/keys-and-certificate"), :body (clojure.spec.alpha/unform :portkey.aws.iot/CreateKeysAndCertificateRequest input58574)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {}) (portkey.awsgen/params-to-querystring {"setAsActive" "setAsActive"}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58573] (clojure.core/let [errors__56772__auto__ {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58573)) (clojure.spec.alpha/unform :portkey.aws.iot/create-keys-and-certificate-response (:body response58573)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58573 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58573)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58573})))))))))))

(clojure.core/defn registercacertificate ([input__56767__auto__] (registercacertificate input__56767__auto__ portkey.aws/*http-client*)) ([input58576 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "POST", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/cacertificate"), :body (clojure.spec.alpha/unform :portkey.aws.iot/RegisterCACertificateRequest input58576)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {}) (portkey.awsgen/params-to-querystring {"setAsActive" "setAsActive", "allowAutoRegistration" "allowAutoRegistration"}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58575] (clojure.core/let [errors__56772__auto__ {"UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "CertificateValidationException" :portkey.aws.iot/certificate-validation-exception, "LimitExceededException" :portkey.aws.iot/limit-exceeded-exception, "ResourceAlreadyExistsException" :portkey.aws.iot/resource-already-exists-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "RegistrationCodeValidationException" :portkey.aws.iot/registration-code-validation-exception}] (if (clojure.core/= nil (:status response58575)) (clojure.spec.alpha/unform :portkey.aws.iot/registercacertificate-response (:body response58575)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58575 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58575)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58575})))))))))))

(clojure.core/defn disable-topic-rule ([input__56767__auto__] (disable-topic-rule input__56767__auto__ portkey.aws/*http-client*)) ([input58578 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "POST", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/rules/{ruleName}/disable"), :body (clojure.spec.alpha/unform :portkey.aws.iot/DisableTopicRuleRequest input58578)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"ruleName" "ruleName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58577] (clojure.core/let [errors__56772__auto__ {"InternalException" :portkey.aws.iot/internal-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception}] (if (clojure.core/= nil (:status response58577)) true (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58577 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58577)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58577})))))))))))

(clojure.core/defn list-topic-rules ([input__56767__auto__] (list-topic-rules input__56767__auto__ portkey.aws/*http-client*)) ([input58580 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/rules"), :body (clojure.spec.alpha/unform :portkey.aws.iot/ListTopicRulesRequest input58580)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {}) (portkey.awsgen/params-to-querystring {"topic" "topic", "maxResults" "maxResults", "nextToken" "nextToken", "ruleDisabled" "ruleDisabled"}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58579] (clojure.core/let [errors__56772__auto__ {"InternalException" :portkey.aws.iot/internal-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception}] (if (clojure.core/= nil (:status response58579)) (clojure.spec.alpha/unform :portkey.aws.iot/list-topic-rules-response (:body response58579)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58579 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58579)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58579})))))))))))

(clojure.core/defn detach-principal-policy ([input__56767__auto__] (detach-principal-policy input__56767__auto__ portkey.aws/*http-client*)) ([input58582 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "DELETE", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/principal-policies/{policyName}"), :body (clojure.spec.alpha/unform :portkey.aws.iot/DetachPrincipalPolicyRequest input58582)} (portkey.awsgen/params-to-header {"principal" ["x-amzn-iot-principal" nil]}) (portkey.awsgen/params-to-uri {"policyName" "policyName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58581] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58581)) true (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58581 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58581)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58581})))))))))))

(clojure.core/defn updatecacertificate ([input__56767__auto__] (updatecacertificate input__56767__auto__ portkey.aws/*http-client*)) ([input58584 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "PUT", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/cacertificate/{caCertificateId}"), :body (clojure.spec.alpha/unform :portkey.aws.iot/UpdateCACertificateRequest input58584)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"caCertificateId" "certificateId"}) (portkey.awsgen/params-to-querystring {"newStatus" "newStatus", "newAutoRegistrationStatus" "newAutoRegistrationStatus"}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58583] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58583)) true (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58583 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58583)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58583})))))))))))

(clojure.core/defn delete-topic-rule ([input__56767__auto__] (delete-topic-rule input__56767__auto__ portkey.aws/*http-client*)) ([input58586 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "DELETE", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/rules/{ruleName}"), :body (clojure.spec.alpha/unform :portkey.aws.iot/DeleteTopicRuleRequest input58586)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"ruleName" "ruleName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58585] (clojure.core/let [errors__56772__auto__ {"InternalException" :portkey.aws.iot/internal-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception}] (if (clojure.core/= nil (:status response58585)) true (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58585 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58585)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58585})))))))))))

(clojure.core/defn describe-certificate ([input__56767__auto__] (describe-certificate input__56767__auto__ portkey.aws/*http-client*)) ([input58588 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/certificates/{certificateId}"), :body (clojure.spec.alpha/unform :portkey.aws.iot/DescribeCertificateRequest input58588)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"certificateId" "certificateId"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58587] (clojure.core/let [errors__56772__auto__ {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}] (if (clojure.core/= nil (:status response58587)) (clojure.spec.alpha/unform :portkey.aws.iot/describe-certificate-response (:body response58587)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58587 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58587)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58587})))))))))))

(clojure.core/defn set-logging-options ([input__56767__auto__] (set-logging-options input__56767__auto__ portkey.aws/*http-client*)) ([input58590 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "POST", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/loggingOptions"), :body (clojure.spec.alpha/unform :portkey.aws.iot/SetLoggingOptionsRequest input58590)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload "loggingOptionsPayload") (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58589] (clojure.core/let [errors__56772__auto__ {"InternalException" :portkey.aws.iot/internal-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception}] (if (clojure.core/= nil (:status response58589)) true (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58589 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58589)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58589})))))))))))

(clojure.core/defn list-thing-principals ([input__56767__auto__] (list-thing-principals input__56767__auto__ portkey.aws/*http-client*)) ([input58592 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/things/{thingName}/principals"), :body (clojure.spec.alpha/unform :portkey.aws.iot/ListThingPrincipalsRequest input58592)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"thingName" "thingName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58591] (clojure.core/let [errors__56772__auto__ {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}] (if (clojure.core/= nil (:status response58591)) (clojure.spec.alpha/unform :portkey.aws.iot/list-thing-principals-response (:body response58591)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58591 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58591)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58591})))))))))))

(clojure.core/defn list-principal-policies ([input__56767__auto__] (list-principal-policies input__56767__auto__ portkey.aws/*http-client*)) ([input58594 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/principal-policies"), :body (clojure.spec.alpha/unform :portkey.aws.iot/ListPrincipalPoliciesRequest input58594)} (portkey.awsgen/params-to-header {"principal" ["x-amzn-iot-principal" nil]}) (portkey.awsgen/params-to-uri {}) (portkey.awsgen/params-to-querystring {"marker" "marker", "pageSize" "pageSize", "isAscendingOrder" "ascendingOrder"}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58593] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58593)) (clojure.spec.alpha/unform :portkey.aws.iot/list-principal-policies-response (:body response58593)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58593 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58593)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58593})))))))))))

(clojure.core/defn transfer-certificate ([input__56767__auto__] (transfer-certificate input__56767__auto__ portkey.aws/*http-client*)) ([input58596 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "PATCH", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/transfer-certificate/{certificateId}"), :body (clojure.spec.alpha/unform :portkey.aws.iot/TransferCertificateRequest input58596)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"certificateId" "certificateId"}) (portkey.awsgen/params-to-querystring {"targetAwsAccount" "targetAwsAccount"}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58595] (clojure.core/let [errors__56772__auto__ {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "CertificateStateException" :portkey.aws.iot/certificate-state-exception, "TransferConflictException" :portkey.aws.iot/transfer-conflict-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58595)) (clojure.spec.alpha/unform :portkey.aws.iot/transfer-certificate-response (:body response58595)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58595 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58595)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58595})))))))))))

(clojure.core/defn delete-policy ([input__56767__auto__] (delete-policy input__56767__auto__ portkey.aws/*http-client*)) ([input58598 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "DELETE", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/policies/{policyName}"), :body (clojure.spec.alpha/unform :portkey.aws.iot/DeletePolicyRequest input58598)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"policyName" "policyName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58597] (clojure.core/let [errors__56772__auto__ {"DeleteConflictException" :portkey.aws.iot/delete-conflict-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58597)) true (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58597 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58597)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58597})))))))))))

(clojure.core/defn update-thing ([input__56767__auto__] (update-thing input__56767__auto__ portkey.aws/*http-client*)) ([input58600 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "PATCH", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/things/{thingName}"), :body (clojure.spec.alpha/unform :portkey.aws.iot/UpdateThingRequest input58600)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"thingName" "thingName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58599] (clojure.core/let [errors__56772__auto__ {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "VersionConflictException" :portkey.aws.iot/version-conflict-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}] (if (clojure.core/= nil (:status response58599)) (clojure.spec.alpha/unform :portkey.aws.iot/update-thing-response (:body response58599)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58599 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58599)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58599})))))))))))

(clojure.core/defn delete-certificate ([input__56767__auto__] (delete-certificate input__56767__auto__ portkey.aws/*http-client*)) ([input58602 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "DELETE", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/certificates/{certificateId}"), :body (clojure.spec.alpha/unform :portkey.aws.iot/DeleteCertificateRequest input58602)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"certificateId" "certificateId"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58601] (clojure.core/let [errors__56772__auto__ {"CertificateStateException" :portkey.aws.iot/certificate-state-exception, "DeleteConflictException" :portkey.aws.iot/delete-conflict-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception}] (if (clojure.core/= nil (:status response58601)) true (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58601 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58601)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58601})))))))))))

(clojure.core/defn get-logging-options ([input__56767__auto__] (get-logging-options input__56767__auto__ portkey.aws/*http-client*)) ([input58604 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/loggingOptions"), :body (clojure.spec.alpha/unform :portkey.aws.iot/GetLoggingOptionsRequest input58604)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58603] (clojure.core/let [errors__56772__auto__ {"InternalException" :portkey.aws.iot/internal-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception}] (if (clojure.core/= nil (:status response58603)) (clojure.spec.alpha/unform :portkey.aws.iot/get-logging-options-response (:body response58603)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58603 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58603)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58603})))))))))))

(clojure.core/defn create-thing-type ([input__56767__auto__] (create-thing-type input__56767__auto__ portkey.aws/*http-client*)) ([input58606 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "POST", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/thing-types/{thingTypeName}"), :body (clojure.spec.alpha/unform :portkey.aws.iot/CreateThingTypeRequest input58606)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"thingTypeName" "thingTypeName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58605] (clojure.core/let [errors__56772__auto__ {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception, "ResourceAlreadyExistsException" :portkey.aws.iot/resource-already-exists-exception}] (if (clojure.core/= nil (:status response58605)) (clojure.spec.alpha/unform :portkey.aws.iot/create-thing-type-response (:body response58605)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58605 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58605)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58605})))))))))))

(clojure.core/defn update-certificate ([input__56767__auto__] (update-certificate input__56767__auto__ portkey.aws/*http-client*)) ([input58608 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "PUT", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/certificates/{certificateId}"), :body (clojure.spec.alpha/unform :portkey.aws.iot/UpdateCertificateRequest input58608)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"certificateId" "certificateId"}) (portkey.awsgen/params-to-querystring {"newStatus" "newStatus"}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58607] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.iot/resource-not-found-exception, "CertificateStateException" :portkey.aws.iot/certificate-state-exception, "InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58607)) true (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58607 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58607)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58607})))))))))))

(clojure.core/defn create-certificate-from-csr ([input__56767__auto__] (create-certificate-from-csr input__56767__auto__ portkey.aws/*http-client*)) ([input58610 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "POST", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/certificates"), :body (clojure.spec.alpha/unform :portkey.aws.iot/CreateCertificateFromCsrRequest input58610)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {}) (portkey.awsgen/params-to-querystring {"setAsActive" "setAsActive"}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58609] (clojure.core/let [errors__56772__auto__ {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58609)) (clojure.spec.alpha/unform :portkey.aws.iot/create-certificate-from-csr-response (:body response58609)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58609 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58609)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58609})))))))))))

(clojure.core/defn list-things ([input__56767__auto__] (list-things input__56767__auto__ portkey.aws/*http-client*)) ([input58612 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.iot/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/things"), :body (clojure.spec.alpha/unform :portkey.aws.iot/ListThingsRequest input58612)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {}) (portkey.awsgen/params-to-querystring {"nextToken" "nextToken", "maxResults" "maxResults", "attributeName" "attributeName", "attributeValue" "attributeValue", "thingTypeName" "thingTypeName"}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response58611] (clojure.core/let [errors__56772__auto__ {"InvalidRequestException" :portkey.aws.iot/invalid-request-exception, "ThrottlingException" :portkey.aws.iot/throttling-exception, "UnauthorizedException" :portkey.aws.iot/unauthorized-exception, "ServiceUnavailableException" :portkey.aws.iot/service-unavailable-exception, "InternalFailureException" :portkey.aws.iot/internal-failure-exception}] (if (clojure.core/= nil (:status response58611)) (clojure.spec.alpha/unform :portkey.aws.iot/list-things-response (:body response58611)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response58611 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response58611)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response58611})))))))))))
