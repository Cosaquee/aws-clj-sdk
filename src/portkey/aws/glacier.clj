(ns portkey.aws.glacier (:require [portkey.aws]))

(def
 endpoints
 '{"ap-northeast-1"
   {:credential-scope {:service "glacier", :region "ap-northeast-1"},
    :ssl-common-name "glacier.ap-northeast-1.amazonaws.com",
    :endpoint "https://glacier.ap-northeast-1.amazonaws.com"},
   "eu-west-1"
   {:credential-scope {:service "glacier", :region "eu-west-1"},
    :ssl-common-name "glacier.eu-west-1.amazonaws.com",
    :endpoint "https://glacier.eu-west-1.amazonaws.com"},
   "us-east-2"
   {:credential-scope {:service "glacier", :region "us-east-2"},
    :ssl-common-name "glacier.us-east-2.amazonaws.com",
    :endpoint "https://glacier.us-east-2.amazonaws.com"},
   "ap-southeast-2"
   {:credential-scope {:service "glacier", :region "ap-southeast-2"},
    :ssl-common-name "glacier.ap-southeast-2.amazonaws.com",
    :endpoint "https://glacier.ap-southeast-2.amazonaws.com"},
   "cn-north-1"
   {:credential-scope {:service "glacier", :region "cn-north-1"},
    :ssl-common-name "glacier.cn-north-1.amazonaws.com.cn",
    :endpoint "https://glacier.cn-north-1.amazonaws.com.cn"},
   "ap-northeast-2"
   {:credential-scope {:service "glacier", :region "ap-northeast-2"},
    :ssl-common-name "glacier.ap-northeast-2.amazonaws.com",
    :endpoint "https://glacier.ap-northeast-2.amazonaws.com"},
   "ca-central-1"
   {:credential-scope {:service "glacier", :region "ca-central-1"},
    :ssl-common-name "glacier.ca-central-1.amazonaws.com",
    :endpoint "https://glacier.ca-central-1.amazonaws.com"},
   "eu-central-1"
   {:credential-scope {:service "glacier", :region "eu-central-1"},
    :ssl-common-name "glacier.eu-central-1.amazonaws.com",
    :endpoint "https://glacier.eu-central-1.amazonaws.com"},
   "eu-west-2"
   {:credential-scope {:service "glacier", :region "eu-west-2"},
    :ssl-common-name "glacier.eu-west-2.amazonaws.com",
    :endpoint "https://glacier.eu-west-2.amazonaws.com"},
   "us-gov-west-1"
   {:credential-scope {:service "glacier", :region "us-gov-west-1"},
    :ssl-common-name "glacier.us-gov-west-1.amazonaws.com",
    :endpoint "https://glacier.us-gov-west-1.amazonaws.com"},
   "us-west-2"
   {:credential-scope {:service "glacier", :region "us-west-2"},
    :ssl-common-name "glacier.us-west-2.amazonaws.com",
    :endpoint "https://glacier.us-west-2.amazonaws.com"},
   "us-east-1"
   {:credential-scope {:service "glacier", :region "us-east-1"},
    :ssl-common-name "glacier.us-east-1.amazonaws.com",
    :endpoint "https://glacier.us-east-1.amazonaws.com"},
   "us-west-1"
   {:credential-scope {:service "glacier", :region "us-west-1"},
    :ssl-common-name "glacier.us-west-1.amazonaws.com",
    :endpoint "https://glacier.us-west-1.amazonaws.com"},
   "ap-south-1"
   {:credential-scope {:service "glacier", :region "ap-south-1"},
    :ssl-common-name "glacier.ap-south-1.amazonaws.com",
    :endpoint "https://glacier.ap-south-1.amazonaws.com"}})

(clojure.spec.alpha/def :portkey.aws.glacier.list-multipart-uploads-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.list-multipart-uploads-input/vault-name (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.list-multipart-uploads-input/marker (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.list-multipart-uploads-input/limit (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/list-multipart-uploads-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.list-multipart-uploads-input/accountId :portkey.aws.glacier.list-multipart-uploads-input/vaultName] :opt-un [:portkey.aws.glacier.list-multipart-uploads-input/marker :portkey.aws.glacier.list-multipart-uploads-input/limit]))

(clojure.spec.alpha/def :portkey.aws.glacier/boolean clojure.core/boolean?)

(clojure.spec.alpha/def :portkey.aws.glacier.provisioned-capacity-description/capacity-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.provisioned-capacity-description/start-date (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.provisioned-capacity-description/expiration-date (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/provisioned-capacity-description (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.provisioned-capacity-description/CapacityId :portkey.aws.glacier.provisioned-capacity-description/StartDate :portkey.aws.glacier.provisioned-capacity-description/ExpirationDate]))

(clojure.spec.alpha/def :portkey.aws.glacier.set-vault-access-policy-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.set-vault-access-policy-input/vault-name (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.set-vault-access-policy-input/policy (clojure.spec.alpha/and :portkey.aws.glacier/vault-access-policy))
(clojure.spec.alpha/def :portkey.aws.glacier/set-vault-access-policy-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.set-vault-access-policy-input/accountId :portkey.aws.glacier.set-vault-access-policy-input/vaultName] :opt-un [:portkey.aws.glacier.set-vault-access-policy-input/policy]))

(clojure.spec.alpha/def :portkey.aws.glacier.get-job-output-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.get-job-output-input/vault-name (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.get-job-output-input/job-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.get-job-output-input/range (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/get-job-output-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.get-job-output-input/accountId :portkey.aws.glacier.get-job-output-input/vaultName :portkey.aws.glacier.get-job-output-input/jobId] :opt-un [:portkey.aws.glacier.get-job-output-input/range]))

(clojure.spec.alpha/def :portkey.aws.glacier.data-retrieval-rule/strategy (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.data-retrieval-rule/bytes-per-hour (clojure.spec.alpha/and :portkey.aws.glacier/nullable-long))
(clojure.spec.alpha/def :portkey.aws.glacier/data-retrieval-rule (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.data-retrieval-rule/Strategy :portkey.aws.glacier.data-retrieval-rule/BytesPerHour]))

(clojure.spec.alpha/def :portkey.aws.glacier/uploads-list (clojure.spec.alpha/coll-of :portkey.aws.glacier/upload-list-element :max-count nil))

(clojure.spec.alpha/def :portkey.aws.glacier.create-vault-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.create-vault-input/vault-name (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/create-vault-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.create-vault-input/accountId :portkey.aws.glacier.create-vault-input/vaultName] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.glacier.get-job-output-output/body (clojure.spec.alpha/and :portkey.aws.glacier/stream))
(clojure.spec.alpha/def :portkey.aws.glacier.get-job-output-output/checksum (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.get-job-output-output/status (clojure.spec.alpha/and :portkey.aws.glacier/httpstatus))
(clojure.spec.alpha/def :portkey.aws.glacier.get-job-output-output/content-range (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.get-job-output-output/accept-ranges (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.get-job-output-output/content-type (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.get-job-output-output/archive-description (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/get-job-output-output (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.get-job-output-output/body :portkey.aws.glacier.get-job-output-output/checksum :portkey.aws.glacier.get-job-output-output/status :portkey.aws.glacier.get-job-output-output/contentRange :portkey.aws.glacier.get-job-output-output/acceptRanges :portkey.aws.glacier.get-job-output-output/contentType :portkey.aws.glacier.get-job-output-output/archiveDescription]))

(clojure.spec.alpha/def :portkey.aws.glacier.initiate-multipart-upload-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.initiate-multipart-upload-input/vault-name (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.initiate-multipart-upload-input/archive-description (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.initiate-multipart-upload-input/part-size (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/initiate-multipart-upload-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.initiate-multipart-upload-input/accountId :portkey.aws.glacier.initiate-multipart-upload-input/vaultName] :opt-un [:portkey.aws.glacier.initiate-multipart-upload-input/archiveDescription :portkey.aws.glacier.initiate-multipart-upload-input/partSize]))

(clojure.spec.alpha/def :portkey.aws.glacier.complete-vault-lock-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.complete-vault-lock-input/vault-name (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.complete-vault-lock-input/lock-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/complete-vault-lock-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.complete-vault-lock-input/accountId :portkey.aws.glacier.complete-vault-lock-input/vaultName :portkey.aws.glacier.complete-vault-lock-input/lockId] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.glacier.part-list-element/range-in-bytes (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.part-list-element/sha256-tree-hash (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/part-list-element (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.part-list-element/RangeInBytes :portkey.aws.glacier.part-list-element/SHA256TreeHash]))

(clojure.spec.alpha/def :portkey.aws.glacier.vault-access-policy/policy (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/vault-access-policy (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.vault-access-policy/Policy]))

(clojure.spec.alpha/def :portkey.aws.glacier/string (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.glacier/job-list (clojure.spec.alpha/coll-of :portkey.aws.glacier/glacier-job-description :max-count nil))

(clojure.spec.alpha/def :portkey.aws.glacier.complete-multipart-upload-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.complete-multipart-upload-input/vault-name (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.complete-multipart-upload-input/upload-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.complete-multipart-upload-input/archive-size (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.complete-multipart-upload-input/checksum (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/complete-multipart-upload-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.complete-multipart-upload-input/accountId :portkey.aws.glacier.complete-multipart-upload-input/vaultName :portkey.aws.glacier.complete-multipart-upload-input/uploadId] :opt-un [:portkey.aws.glacier.complete-multipart-upload-input/archiveSize :portkey.aws.glacier.complete-multipart-upload-input/checksum]))

(clojure.spec.alpha/def :portkey.aws.glacier/status-code (clojure.spec.alpha/conformer (clojure.core/let [m__56599__auto__ {"InProgress" "InProgress", :in-progress "InProgress", "Succeeded" "Succeeded", :succeeded "Succeeded", "Failed" "Failed", :failed "Failed"}] (clojure.core/fn [s__56600__auto__] (m__56599__auto__ s__56600__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.awsgen/dashed)))

(clojure.spec.alpha/def :portkey.aws.glacier.list-multipart-uploads-output/marker (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/list-multipart-uploads-output (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier/UploadsList :portkey.aws.glacier.list-multipart-uploads-output/Marker]))

(clojure.spec.alpha/def :portkey.aws.glacier.create-vault-output/location (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/create-vault-output (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.create-vault-output/location]))

(clojure.spec.alpha/def :portkey.aws.glacier.list-provisioned-capacity-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/list-provisioned-capacity-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.list-provisioned-capacity-input/accountId] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.glacier/long clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.glacier.purchase-provisioned-capacity-output/capacity-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/purchase-provisioned-capacity-output (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.purchase-provisioned-capacity-output/capacityId]))

(clojure.spec.alpha/def :portkey.aws.glacier/tag-key (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.glacier.get-data-retrieval-policy-output/policy (clojure.spec.alpha/and :portkey.aws.glacier/data-retrieval-policy))
(clojure.spec.alpha/def :portkey.aws.glacier/get-data-retrieval-policy-output (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.get-data-retrieval-policy-output/Policy]))

(clojure.spec.alpha/def :portkey.aws.glacier.inventory-retrieval-job-description/format (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.inventory-retrieval-job-description/start-date (clojure.spec.alpha/and :portkey.aws.glacier/date-time))
(clojure.spec.alpha/def :portkey.aws.glacier.inventory-retrieval-job-description/end-date (clojure.spec.alpha/and :portkey.aws.glacier/date-time))
(clojure.spec.alpha/def :portkey.aws.glacier.inventory-retrieval-job-description/limit (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.inventory-retrieval-job-description/marker (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/inventory-retrieval-job-description (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.inventory-retrieval-job-description/Format :portkey.aws.glacier.inventory-retrieval-job-description/StartDate :portkey.aws.glacier.inventory-retrieval-job-description/EndDate :portkey.aws.glacier.inventory-retrieval-job-description/Limit :portkey.aws.glacier.inventory-retrieval-job-description/Marker]))

(clojure.spec.alpha/def :portkey.aws.glacier.limit-exceeded-exception/type (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.limit-exceeded-exception/code (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.limit-exceeded-exception/message (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/limit-exceeded-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.limit-exceeded-exception/type :portkey.aws.glacier.limit-exceeded-exception/code :portkey.aws.glacier.limit-exceeded-exception/message]))

(clojure.spec.alpha/def :portkey.aws.glacier.delete-archive-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.delete-archive-input/vault-name (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.delete-archive-input/archive-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/delete-archive-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.delete-archive-input/accountId :portkey.aws.glacier.delete-archive-input/vaultName :portkey.aws.glacier.delete-archive-input/archiveId] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.glacier.set-data-retrieval-policy-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.set-data-retrieval-policy-input/policy (clojure.spec.alpha/and :portkey.aws.glacier/data-retrieval-policy))
(clojure.spec.alpha/def :portkey.aws.glacier/set-data-retrieval-policy-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.set-data-retrieval-policy-input/accountId] :opt-un [:portkey.aws.glacier.set-data-retrieval-policy-input/Policy]))

(clojure.spec.alpha/def :portkey.aws.glacier.get-vault-lock-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.get-vault-lock-input/vault-name (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/get-vault-lock-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.get-vault-lock-input/accountId :portkey.aws.glacier.get-vault-lock-input/vaultName] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.glacier.vault-notification-config/snstopic (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.vault-notification-config/events (clojure.spec.alpha/and :portkey.aws.glacier/notification-event-list))
(clojure.spec.alpha/def :portkey.aws.glacier/vault-notification-config (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.vault-notification-config/SNSTopic :portkey.aws.glacier.vault-notification-config/Events]))

(clojure.spec.alpha/def :portkey.aws.glacier/provisioned-capacity-list (clojure.spec.alpha/coll-of :portkey.aws.glacier/provisioned-capacity-description :max-count nil))

(clojure.spec.alpha/def :portkey.aws.glacier.list-parts-output/multipart-upload-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.list-parts-output/vaultarn (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.list-parts-output/archive-description (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.list-parts-output/part-size-in-bytes (clojure.spec.alpha/and :portkey.aws.glacier/long))
(clojure.spec.alpha/def :portkey.aws.glacier.list-parts-output/creation-date (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.list-parts-output/parts (clojure.spec.alpha/and :portkey.aws.glacier/part-list))
(clojure.spec.alpha/def :portkey.aws.glacier.list-parts-output/marker (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/list-parts-output (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.list-parts-output/MultipartUploadId :portkey.aws.glacier.list-parts-output/VaultARN :portkey.aws.glacier.list-parts-output/ArchiveDescription :portkey.aws.glacier.list-parts-output/PartSizeInBytes :portkey.aws.glacier.list-parts-output/CreationDate :portkey.aws.glacier.list-parts-output/Parts :portkey.aws.glacier.list-parts-output/Marker]))

(clojure.spec.alpha/def :portkey.aws.glacier.list-jobs-output/marker (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/list-jobs-output (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier/JobList :portkey.aws.glacier.list-jobs-output/Marker]))

(clojure.spec.alpha/def :portkey.aws.glacier/vault-list (clojure.spec.alpha/coll-of :portkey.aws.glacier/describe-vault-output :max-count nil))

(clojure.spec.alpha/def :portkey.aws.glacier.service-unavailable-exception/type (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.service-unavailable-exception/code (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.service-unavailable-exception/message (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/service-unavailable-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.service-unavailable-exception/type :portkey.aws.glacier.service-unavailable-exception/code :portkey.aws.glacier.service-unavailable-exception/message]))

(clojure.spec.alpha/def :portkey.aws.glacier.upload-multipart-part-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.upload-multipart-part-input/vault-name (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.upload-multipart-part-input/upload-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.upload-multipart-part-input/checksum (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.upload-multipart-part-input/range (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.upload-multipart-part-input/body (clojure.spec.alpha/and :portkey.aws.glacier/stream))
(clojure.spec.alpha/def :portkey.aws.glacier/upload-multipart-part-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.upload-multipart-part-input/accountId :portkey.aws.glacier.upload-multipart-part-input/vaultName :portkey.aws.glacier.upload-multipart-part-input/uploadId] :opt-un [:portkey.aws.glacier.upload-multipart-part-input/checksum :portkey.aws.glacier.upload-multipart-part-input/range :portkey.aws.glacier.upload-multipart-part-input/body]))

(clojure.spec.alpha/def :portkey.aws.glacier.initiate-vault-lock-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.initiate-vault-lock-input/vault-name (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.initiate-vault-lock-input/policy (clojure.spec.alpha/and :portkey.aws.glacier/vault-lock-policy))
(clojure.spec.alpha/def :portkey.aws.glacier/initiate-vault-lock-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.initiate-vault-lock-input/accountId :portkey.aws.glacier.initiate-vault-lock-input/vaultName] :opt-un [:portkey.aws.glacier.initiate-vault-lock-input/policy]))

(clojure.spec.alpha/def :portkey.aws.glacier.data-retrieval-policy/rules (clojure.spec.alpha/and :portkey.aws.glacier/data-retrieval-rules-list))
(clojure.spec.alpha/def :portkey.aws.glacier/data-retrieval-policy (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.data-retrieval-policy/Rules]))

(clojure.spec.alpha/def :portkey.aws.glacier/action-code (clojure.spec.alpha/conformer (clojure.core/let [m__56599__auto__ {"ArchiveRetrieval" "ArchiveRetrieval", :archive-retrieval "ArchiveRetrieval", "InventoryRetrieval" "InventoryRetrieval", :inventory-retrieval "InventoryRetrieval"}] (clojure.core/fn [s__56600__auto__] (m__56599__auto__ s__56600__auto__ :clojure.spec.alpha/invalid))) (clojure.core/comp clojure.core/keyword portkey.awsgen/dashed)))

(clojure.spec.alpha/def :portkey.aws.glacier.delete-vault-access-policy-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.delete-vault-access-policy-input/vault-name (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/delete-vault-access-policy-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.delete-vault-access-policy-input/accountId :portkey.aws.glacier.delete-vault-access-policy-input/vaultName] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.glacier.list-tags-for-vault-output/tags (clojure.spec.alpha/and :portkey.aws.glacier/tag-map))
(clojure.spec.alpha/def :portkey.aws.glacier/list-tags-for-vault-output (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.list-tags-for-vault-output/Tags]))

(clojure.spec.alpha/def :portkey.aws.glacier.get-vault-notifications-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.get-vault-notifications-input/vault-name (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/get-vault-notifications-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.get-vault-notifications-input/accountId :portkey.aws.glacier.get-vault-notifications-input/vaultName] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.glacier.get-data-retrieval-policy-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/get-data-retrieval-policy-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.get-data-retrieval-policy-input/accountId] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.glacier.abort-multipart-upload-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.abort-multipart-upload-input/vault-name (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.abort-multipart-upload-input/upload-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/abort-multipart-upload-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.abort-multipart-upload-input/accountId :portkey.aws.glacier.abort-multipart-upload-input/vaultName :portkey.aws.glacier.abort-multipart-upload-input/uploadId] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.glacier/tag-key-list (clojure.spec.alpha/coll-of :portkey.aws.glacier/string :max-count nil))

(clojure.spec.alpha/def :portkey.aws.glacier.get-vault-access-policy-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.get-vault-access-policy-input/vault-name (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/get-vault-access-policy-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.get-vault-access-policy-input/accountId :portkey.aws.glacier.get-vault-access-policy-input/vaultName] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.glacier.delete-vault-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.delete-vault-input/vault-name (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/delete-vault-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.delete-vault-input/accountId :portkey.aws.glacier.delete-vault-input/vaultName] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.glacier.resource-not-found-exception/type (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.resource-not-found-exception/code (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.resource-not-found-exception/message (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/resource-not-found-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.resource-not-found-exception/type :portkey.aws.glacier.resource-not-found-exception/code :portkey.aws.glacier.resource-not-found-exception/message]))

(clojure.spec.alpha/def :portkey.aws.glacier.policy-enforced-exception/type (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.policy-enforced-exception/code (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.policy-enforced-exception/message (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/policy-enforced-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.policy-enforced-exception/type :portkey.aws.glacier.policy-enforced-exception/code :portkey.aws.glacier.policy-enforced-exception/message]))

(clojure.spec.alpha/def :portkey.aws.glacier/nullable-long clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.glacier.purchase-provisioned-capacity-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/purchase-provisioned-capacity-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.purchase-provisioned-capacity-input/accountId] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.glacier.describe-vault-output/vaultarn (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.describe-vault-output/vault-name (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.describe-vault-output/creation-date (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.describe-vault-output/last-inventory-date (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.describe-vault-output/number-of-archives (clojure.spec.alpha/and :portkey.aws.glacier/long))
(clojure.spec.alpha/def :portkey.aws.glacier.describe-vault-output/size-in-bytes (clojure.spec.alpha/and :portkey.aws.glacier/long))
(clojure.spec.alpha/def :portkey.aws.glacier/describe-vault-output (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.describe-vault-output/VaultARN :portkey.aws.glacier.describe-vault-output/VaultName :portkey.aws.glacier.describe-vault-output/CreationDate :portkey.aws.glacier.describe-vault-output/LastInventoryDate :portkey.aws.glacier.describe-vault-output/NumberOfArchives :portkey.aws.glacier.describe-vault-output/SizeInBytes]))

(clojure.spec.alpha/def :portkey.aws.glacier/tag-value (clojure.spec.alpha/and clojure.core/string?))

(clojure.spec.alpha/def :portkey.aws.glacier.vault-lock-policy/policy (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/vault-lock-policy (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.vault-lock-policy/Policy]))

(clojure.spec.alpha/def :portkey.aws.glacier.get-vault-lock-output/policy (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.get-vault-lock-output/state (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.get-vault-lock-output/expiration-date (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.get-vault-lock-output/creation-date (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/get-vault-lock-output (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.get-vault-lock-output/Policy :portkey.aws.glacier.get-vault-lock-output/State :portkey.aws.glacier.get-vault-lock-output/ExpirationDate :portkey.aws.glacier.get-vault-lock-output/CreationDate]))

(clojure.spec.alpha/def :portkey.aws.glacier.add-tags-to-vault-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.add-tags-to-vault-input/vault-name (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.add-tags-to-vault-input/tags (clojure.spec.alpha/and :portkey.aws.glacier/tag-map))
(clojure.spec.alpha/def :portkey.aws.glacier/add-tags-to-vault-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.add-tags-to-vault-input/accountId :portkey.aws.glacier.add-tags-to-vault-input/vaultName] :opt-un [:portkey.aws.glacier.add-tags-to-vault-input/Tags]))

(clojure.spec.alpha/def :portkey.aws.glacier.initiate-job-output/location (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.initiate-job-output/job-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/initiate-job-output (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.initiate-job-output/location :portkey.aws.glacier.initiate-job-output/jobId]))

(clojure.spec.alpha/def :portkey.aws.glacier.get-vault-notifications-output/vault-notification-config (clojure.spec.alpha/and :portkey.aws.glacier/vault-notification-config))
(clojure.spec.alpha/def :portkey.aws.glacier/get-vault-notifications-output (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.get-vault-notifications-output/vaultNotificationConfig]))

(clojure.spec.alpha/def :portkey.aws.glacier.list-jobs-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.list-jobs-input/vault-name (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.list-jobs-input/limit (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.list-jobs-input/marker (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.list-jobs-input/statuscode (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.list-jobs-input/completed (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/list-jobs-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.list-jobs-input/accountId :portkey.aws.glacier.list-jobs-input/vaultName] :opt-un [:portkey.aws.glacier.list-jobs-input/limit :portkey.aws.glacier.list-jobs-input/marker :portkey.aws.glacier.list-jobs-input/statuscode :portkey.aws.glacier.list-jobs-input/completed]))

(clojure.spec.alpha/def :portkey.aws.glacier/part-list (clojure.spec.alpha/coll-of :portkey.aws.glacier/part-list-element :max-count nil))

(clojure.spec.alpha/def :portkey.aws.glacier/tag-map (clojure.spec.alpha/map-of :portkey.aws.glacier/tag-key :portkey.aws.glacier/tag-value))

(clojure.spec.alpha/def :portkey.aws.glacier/size clojure.core/int?)

(clojure.spec.alpha/def :portkey.aws.glacier.request-timeout-exception/type (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.request-timeout-exception/code (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.request-timeout-exception/message (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/request-timeout-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.request-timeout-exception/type :portkey.aws.glacier.request-timeout-exception/code :portkey.aws.glacier.request-timeout-exception/message]))

(clojure.spec.alpha/def :portkey.aws.glacier.upload-list-element/multipart-upload-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.upload-list-element/vaultarn (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.upload-list-element/archive-description (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.upload-list-element/part-size-in-bytes (clojure.spec.alpha/and :portkey.aws.glacier/long))
(clojure.spec.alpha/def :portkey.aws.glacier.upload-list-element/creation-date (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/upload-list-element (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.upload-list-element/MultipartUploadId :portkey.aws.glacier.upload-list-element/VaultARN :portkey.aws.glacier.upload-list-element/ArchiveDescription :portkey.aws.glacier.upload-list-element/PartSizeInBytes :portkey.aws.glacier.upload-list-element/CreationDate]))

(clojure.spec.alpha/def :portkey.aws.glacier.list-vaults-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.list-vaults-input/marker (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.list-vaults-input/limit (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/list-vaults-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.list-vaults-input/accountId] :opt-un [:portkey.aws.glacier.list-vaults-input/marker :portkey.aws.glacier.list-vaults-input/limit]))

(clojure.spec.alpha/def :portkey.aws.glacier/stream (clojure.spec.alpha/and clojure.core/bytes? (clojure.spec.alpha/conformer portkey.awsgen/base64-encode portkey.awsgen/base64-decode)))

(clojure.spec.alpha/def :portkey.aws.glacier.initiate-job-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.initiate-job-input/vault-name (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.initiate-job-input/job-parameters (clojure.spec.alpha/and :portkey.aws.glacier/job-parameters))
(clojure.spec.alpha/def :portkey.aws.glacier/initiate-job-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.initiate-job-input/accountId :portkey.aws.glacier.initiate-job-input/vaultName] :opt-un [:portkey.aws.glacier.initiate-job-input/jobParameters]))

(clojure.spec.alpha/def :portkey.aws.glacier.initiate-vault-lock-output/lock-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/initiate-vault-lock-output (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.initiate-vault-lock-output/lockId]))

(clojure.spec.alpha/def :portkey.aws.glacier.describe-vault-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.describe-vault-input/vault-name (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/describe-vault-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.describe-vault-input/accountId :portkey.aws.glacier.describe-vault-input/vaultName] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.glacier.remove-tags-from-vault-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.remove-tags-from-vault-input/vault-name (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.remove-tags-from-vault-input/tag-keys (clojure.spec.alpha/and :portkey.aws.glacier/tag-key-list))
(clojure.spec.alpha/def :portkey.aws.glacier/remove-tags-from-vault-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.remove-tags-from-vault-input/accountId :portkey.aws.glacier.remove-tags-from-vault-input/vaultName] :opt-un [:portkey.aws.glacier.remove-tags-from-vault-input/TagKeys]))

(clojure.spec.alpha/def :portkey.aws.glacier.list-tags-for-vault-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.list-tags-for-vault-input/vault-name (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/list-tags-for-vault-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.list-tags-for-vault-input/accountId :portkey.aws.glacier.list-tags-for-vault-input/vaultName] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.glacier.insufficient-capacity-exception/type (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.insufficient-capacity-exception/code (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.insufficient-capacity-exception/message (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/insufficient-capacity-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.insufficient-capacity-exception/type :portkey.aws.glacier.insufficient-capacity-exception/code :portkey.aws.glacier.insufficient-capacity-exception/message]))

(clojure.spec.alpha/def :portkey.aws.glacier.delete-vault-notifications-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.delete-vault-notifications-input/vault-name (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/delete-vault-notifications-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.delete-vault-notifications-input/accountId :portkey.aws.glacier.delete-vault-notifications-input/vaultName] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.glacier.describe-job-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.describe-job-input/vault-name (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.describe-job-input/job-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/describe-job-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.describe-job-input/accountId :portkey.aws.glacier.describe-job-input/vaultName :portkey.aws.glacier.describe-job-input/jobId] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.glacier.glacier-job-description/tier (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.glacier-job-description/completion-date (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.glacier-job-description/archive-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.glacier-job-description/status-message (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.glacier-job-description/archive-size-in-bytes (clojure.spec.alpha/and :portkey.aws.glacier/size))
(clojure.spec.alpha/def :portkey.aws.glacier.glacier-job-description/snstopic (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.glacier-job-description/vaultarn (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.glacier-job-description/inventory-retrieval-parameters (clojure.spec.alpha/and :portkey.aws.glacier/inventory-retrieval-job-description))
(clojure.spec.alpha/def :portkey.aws.glacier.glacier-job-description/archivesha256-tree-hash (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.glacier-job-description/sha256-tree-hash (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.glacier-job-description/creation-date (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.glacier-job-description/inventory-size-in-bytes (clojure.spec.alpha/and :portkey.aws.glacier/size))
(clojure.spec.alpha/def :portkey.aws.glacier.glacier-job-description/completed (clojure.spec.alpha/and :portkey.aws.glacier/boolean))
(clojure.spec.alpha/def :portkey.aws.glacier.glacier-job-description/action (clojure.spec.alpha/and :portkey.aws.glacier/action-code))
(clojure.spec.alpha/def :portkey.aws.glacier.glacier-job-description/job-description (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.glacier-job-description/retrieval-byte-range (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.glacier-job-description/job-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/glacier-job-description (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.glacier-job-description/Tier :portkey.aws.glacier.glacier-job-description/CompletionDate :portkey.aws.glacier/StatusCode :portkey.aws.glacier.glacier-job-description/ArchiveId :portkey.aws.glacier.glacier-job-description/StatusMessage :portkey.aws.glacier.glacier-job-description/ArchiveSizeInBytes :portkey.aws.glacier.glacier-job-description/SNSTopic :portkey.aws.glacier.glacier-job-description/VaultARN :portkey.aws.glacier.glacier-job-description/InventoryRetrievalParameters :portkey.aws.glacier.glacier-job-description/ArchiveSHA256TreeHash :portkey.aws.glacier.glacier-job-description/SHA256TreeHash :portkey.aws.glacier.glacier-job-description/CreationDate :portkey.aws.glacier.glacier-job-description/InventorySizeInBytes :portkey.aws.glacier.glacier-job-description/Completed :portkey.aws.glacier.glacier-job-description/Action :portkey.aws.glacier.glacier-job-description/JobDescription :portkey.aws.glacier.glacier-job-description/RetrievalByteRange :portkey.aws.glacier.glacier-job-description/JobId]))

(clojure.spec.alpha/def :portkey.aws.glacier.missing-parameter-value-exception/type (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.missing-parameter-value-exception/code (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.missing-parameter-value-exception/message (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/missing-parameter-value-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.missing-parameter-value-exception/type :portkey.aws.glacier.missing-parameter-value-exception/code :portkey.aws.glacier.missing-parameter-value-exception/message]))

(clojure.spec.alpha/def :portkey.aws.glacier.initiate-multipart-upload-output/location (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.initiate-multipart-upload-output/upload-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/initiate-multipart-upload-output (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.initiate-multipart-upload-output/location :portkey.aws.glacier.initiate-multipart-upload-output/uploadId]))

(clojure.spec.alpha/def :portkey.aws.glacier.list-parts-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.list-parts-input/vault-name (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.list-parts-input/upload-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.list-parts-input/marker (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.list-parts-input/limit (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/list-parts-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.list-parts-input/accountId :portkey.aws.glacier.list-parts-input/vaultName :portkey.aws.glacier.list-parts-input/uploadId] :opt-un [:portkey.aws.glacier.list-parts-input/marker :portkey.aws.glacier.list-parts-input/limit]))

(clojure.spec.alpha/def :portkey.aws.glacier.get-vault-access-policy-output/policy (clojure.spec.alpha/and :portkey.aws.glacier/vault-access-policy))
(clojure.spec.alpha/def :portkey.aws.glacier/get-vault-access-policy-output (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.get-vault-access-policy-output/policy]))

(clojure.spec.alpha/def :portkey.aws.glacier.archive-creation-output/location (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.archive-creation-output/checksum (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.archive-creation-output/archive-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/archive-creation-output (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.archive-creation-output/location :portkey.aws.glacier.archive-creation-output/checksum :portkey.aws.glacier.archive-creation-output/archiveId]))

(clojure.spec.alpha/def :portkey.aws.glacier/list-provisioned-capacity-output (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier/ProvisionedCapacityList]))

(clojure.spec.alpha/def :portkey.aws.glacier.inventory-retrieval-job-input/start-date (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.inventory-retrieval-job-input/end-date (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.inventory-retrieval-job-input/limit (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.inventory-retrieval-job-input/marker (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/inventory-retrieval-job-input (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.inventory-retrieval-job-input/StartDate :portkey.aws.glacier.inventory-retrieval-job-input/EndDate :portkey.aws.glacier.inventory-retrieval-job-input/Limit :portkey.aws.glacier.inventory-retrieval-job-input/Marker]))

(clojure.spec.alpha/def :portkey.aws.glacier.upload-multipart-part-output/checksum (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/upload-multipart-part-output (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.upload-multipart-part-output/checksum]))

(clojure.spec.alpha/def :portkey.aws.glacier.upload-archive-input/vault-name (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.upload-archive-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.upload-archive-input/archive-description (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.upload-archive-input/checksum (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.upload-archive-input/body (clojure.spec.alpha/and :portkey.aws.glacier/stream))
(clojure.spec.alpha/def :portkey.aws.glacier/upload-archive-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.upload-archive-input/vaultName :portkey.aws.glacier.upload-archive-input/accountId] :opt-un [:portkey.aws.glacier.upload-archive-input/archiveDescription :portkey.aws.glacier.upload-archive-input/checksum :portkey.aws.glacier.upload-archive-input/body]))

(clojure.spec.alpha/def :portkey.aws.glacier/data-retrieval-rules-list (clojure.spec.alpha/coll-of :portkey.aws.glacier/data-retrieval-rule :max-count nil))

(clojure.spec.alpha/def :portkey.aws.glacier.invalid-parameter-value-exception/type (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.invalid-parameter-value-exception/code (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.invalid-parameter-value-exception/message (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/invalid-parameter-value-exception (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.invalid-parameter-value-exception/type :portkey.aws.glacier.invalid-parameter-value-exception/code :portkey.aws.glacier.invalid-parameter-value-exception/message]))

(clojure.spec.alpha/def :portkey.aws.glacier.abort-vault-lock-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.abort-vault-lock-input/vault-name (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/abort-vault-lock-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.abort-vault-lock-input/accountId :portkey.aws.glacier.abort-vault-lock-input/vaultName] :opt-un []))

(clojure.spec.alpha/def :portkey.aws.glacier.list-vaults-output/marker (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier/list-vaults-output (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier/VaultList :portkey.aws.glacier.list-vaults-output/Marker]))

(clojure.spec.alpha/def :portkey.aws.glacier.job-parameters/format (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.job-parameters/type (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.job-parameters/archive-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.job-parameters/description (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.job-parameters/snstopic (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.job-parameters/retrieval-byte-range (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.job-parameters/tier (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.job-parameters/inventory-retrieval-parameters (clojure.spec.alpha/and :portkey.aws.glacier/inventory-retrieval-job-input))
(clojure.spec.alpha/def :portkey.aws.glacier/job-parameters (portkey.awsgen/json-keys :req-un [] :opt-un [:portkey.aws.glacier.job-parameters/Format :portkey.aws.glacier.job-parameters/Type :portkey.aws.glacier.job-parameters/ArchiveId :portkey.aws.glacier.job-parameters/Description :portkey.aws.glacier.job-parameters/SNSTopic :portkey.aws.glacier.job-parameters/RetrievalByteRange :portkey.aws.glacier.job-parameters/Tier :portkey.aws.glacier.job-parameters/InventoryRetrievalParameters]))

(clojure.spec.alpha/def :portkey.aws.glacier.set-vault-notifications-input/account-id (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.set-vault-notifications-input/vault-name (clojure.spec.alpha/and :portkey.aws.glacier/string))
(clojure.spec.alpha/def :portkey.aws.glacier.set-vault-notifications-input/vault-notification-config (clojure.spec.alpha/and :portkey.aws.glacier/vault-notification-config))
(clojure.spec.alpha/def :portkey.aws.glacier/set-vault-notifications-input (portkey.awsgen/json-keys :req-un [:portkey.aws.glacier.set-vault-notifications-input/accountId :portkey.aws.glacier.set-vault-notifications-input/vaultName] :opt-un [:portkey.aws.glacier.set-vault-notifications-input/vaultNotificationConfig]))

(clojure.spec.alpha/def :portkey.aws.glacier/notification-event-list (clojure.spec.alpha/coll-of :portkey.aws.glacier/string :max-count nil))

(clojure.spec.alpha/def :portkey.aws.glacier/httpstatus (clojure.spec.alpha/and clojure.core/int?))

(clojure.spec.alpha/def :portkey.aws.glacier/date-time (clojure.spec.alpha/and clojure.core/string?))

(clojure.core/defn initiate-multipart-upload ([input__56767__auto__] (initiate-multipart-upload input__56767__auto__ portkey.aws/*http-client*)) ([input57594 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "POST", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/vaults/{vaultName}/multipart-uploads"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/InitiateMultipartUploadInput input57594)} (portkey.awsgen/params-to-header {"archiveDescription" ["x-amz-archive-description" nil], "partSize" ["x-amz-part-size" nil]}) (portkey.awsgen/params-to-uri {"accountId" "accountId", "vaultName" "vaultName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57593] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.glacier/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception}] (if (clojure.core/= 201 (:status response57593)) (clojure.spec.alpha/unform :portkey.aws.glacier/initiate-multipart-upload-output (:body response57593)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57593 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57593)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57593})))))))))))

(clojure.core/defn describe-vault ([input__56767__auto__] (describe-vault input__56767__auto__ portkey.aws/*http-client*)) ([input57596 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/vaults/{vaultName}"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/DescribeVaultInput input57596)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"accountId" "accountId", "vaultName" "vaultName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57595] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.glacier/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception}] (if (clojure.core/= nil (:status response57595)) (clojure.spec.alpha/unform :portkey.aws.glacier/describe-vault-output (:body response57595)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57595 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57595)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57595})))))))))))

(clojure.core/defn initiate-job ([input__56767__auto__] (initiate-job input__56767__auto__ portkey.aws/*http-client*)) ([input57598 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "POST", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/vaults/{vaultName}/jobs"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/InitiateJobInput input57598)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"accountId" "accountId", "vaultName" "vaultName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload "jobParameters") (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57597] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.glacier/resource-not-found-exception, "PolicyEnforcedException" :portkey.aws.glacier/policy-enforced-exception, "InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "InsufficientCapacityException" :portkey.aws.glacier/insufficient-capacity-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception}] (if (clojure.core/= 202 (:status response57597)) (clojure.spec.alpha/unform :portkey.aws.glacier/initiate-job-output (:body response57597)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57597 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57597)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57597})))))))))))

(clojure.core/defn delete-vault-notifications ([input__56767__auto__] (delete-vault-notifications input__56767__auto__ portkey.aws/*http-client*)) ([input57600 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "DELETE", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/vaults/{vaultName}/notification-configuration"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/DeleteVaultNotificationsInput input57600)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"accountId" "accountId", "vaultName" "vaultName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57599] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.glacier/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception}] (if (clojure.core/= 204 (:status response57599)) true (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57599 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57599)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57599})))))))))))

(clojure.core/defn get-vault-notifications ([input__56767__auto__] (get-vault-notifications input__56767__auto__ portkey.aws/*http-client*)) ([input57602 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/vaults/{vaultName}/notification-configuration"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/GetVaultNotificationsInput input57602)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"accountId" "accountId", "vaultName" "vaultName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57601] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.glacier/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception}] (if (clojure.core/= nil (:status response57601)) (clojure.spec.alpha/unform :portkey.aws.glacier/get-vault-notifications-output (:body response57601)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57601 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57601)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57601})))))))))))

(clojure.core/defn set-vault-notifications ([input__56767__auto__] (set-vault-notifications input__56767__auto__ portkey.aws/*http-client*)) ([input57604 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "PUT", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/vaults/{vaultName}/notification-configuration"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/SetVaultNotificationsInput input57604)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"accountId" "accountId", "vaultName" "vaultName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload "vaultNotificationConfig") (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57603] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.glacier/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception}] (if (clojure.core/= 204 (:status response57603)) true (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57603 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57603)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57603})))))))))))

(clojure.core/defn list-tags-for-vault ([input__56767__auto__] (list-tags-for-vault input__56767__auto__ portkey.aws/*http-client*)) ([input57606 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/vaults/{vaultName}/tags"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/ListTagsForVaultInput input57606)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"accountId" "accountId", "vaultName" "vaultName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57605] (clojure.core/let [errors__56772__auto__ {"InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "ResourceNotFoundException" :portkey.aws.glacier/resource-not-found-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception}] (if (clojure.core/= nil (:status response57605)) (clojure.spec.alpha/unform :portkey.aws.glacier/list-tags-for-vault-output (:body response57605)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57605 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57605)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57605})))))))))))

(clojure.core/defn list-multipart-uploads ([input__56767__auto__] (list-multipart-uploads input__56767__auto__ portkey.aws/*http-client*)) ([input57608 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/vaults/{vaultName}/multipart-uploads"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/ListMultipartUploadsInput input57608)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"accountId" "accountId", "vaultName" "vaultName"}) (portkey.awsgen/params-to-querystring {"marker" "marker", "limit" "limit"}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57607] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.glacier/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception}] (if (clojure.core/= nil (:status response57607)) (clojure.spec.alpha/unform :portkey.aws.glacier/list-multipart-uploads-output (:body response57607)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57607 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57607)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57607})))))))))))

(clojure.core/defn delete-vault-access-policy ([input__56767__auto__] (delete-vault-access-policy input__56767__auto__ portkey.aws/*http-client*)) ([input57610 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "DELETE", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/vaults/{vaultName}/access-policy"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/DeleteVaultAccessPolicyInput input57610)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"accountId" "accountId", "vaultName" "vaultName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57609] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.glacier/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception}] (if (clojure.core/= 204 (:status response57609)) true (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57609 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57609)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57609})))))))))))

(clojure.core/defn get-data-retrieval-policy ([input__56767__auto__] (get-data-retrieval-policy input__56767__auto__ portkey.aws/*http-client*)) ([input57612 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/policies/data-retrieval"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/GetDataRetrievalPolicyInput input57612)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"accountId" "accountId"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57611] (clojure.core/let [errors__56772__auto__ {"InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception}] (if (clojure.core/= nil (:status response57611)) (clojure.spec.alpha/unform :portkey.aws.glacier/get-data-retrieval-policy-output (:body response57611)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57611 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57611)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57611})))))))))))

(clojure.core/defn purchase-provisioned-capacity ([input__56767__auto__] (purchase-provisioned-capacity input__56767__auto__ portkey.aws/*http-client*)) ([input57614 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "POST", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/provisioned-capacity"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/PurchaseProvisionedCapacityInput input57614)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"accountId" "accountId"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57613] (clojure.core/let [errors__56772__auto__ {"InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "LimitExceededException" :portkey.aws.glacier/limit-exceeded-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception}] (if (clojure.core/= 201 (:status response57613)) (clojure.spec.alpha/unform :portkey.aws.glacier/purchase-provisioned-capacity-output (:body response57613)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57613 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57613)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57613})))))))))))

(clojure.core/defn delete-archive ([input__56767__auto__] (delete-archive input__56767__auto__ portkey.aws/*http-client*)) ([input57616 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "DELETE", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/vaults/{vaultName}/archives/{archiveId}"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/DeleteArchiveInput input57616)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"accountId" "accountId", "vaultName" "vaultName", "archiveId" "archiveId"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57615] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.glacier/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception}] (if (clojure.core/= 204 (:status response57615)) true (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57615 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57615)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57615})))))))))))

(clojure.core/defn describe-job ([input__56767__auto__] (describe-job input__56767__auto__ portkey.aws/*http-client*)) ([input57618 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/vaults/{vaultName}/jobs/{jobId}"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/DescribeJobInput input57618)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"accountId" "accountId", "vaultName" "vaultName", "jobId" "jobId"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57617] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.glacier/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception}] (if (clojure.core/= nil (:status response57617)) (clojure.spec.alpha/unform :portkey.aws.glacier/glacier-job-description (:body response57617)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57617 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57617)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57617})))))))))))

(clojure.core/defn complete-multipart-upload ([input__56767__auto__] (complete-multipart-upload input__56767__auto__ portkey.aws/*http-client*)) ([input57620 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "POST", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/vaults/{vaultName}/multipart-uploads/{uploadId}"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/CompleteMultipartUploadInput input57620)} (portkey.awsgen/params-to-header {"archiveSize" ["x-amz-archive-size" nil], "checksum" ["x-amz-sha256-tree-hash" nil]}) (portkey.awsgen/params-to-uri {"accountId" "accountId", "vaultName" "vaultName", "uploadId" "uploadId"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57619] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.glacier/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception}] (if (clojure.core/= 201 (:status response57619)) (clojure.spec.alpha/unform :portkey.aws.glacier/archive-creation-output (:body response57619)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57619 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57619)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57619})))))))))))

(clojure.core/defn abort-multipart-upload ([input__56767__auto__] (abort-multipart-upload input__56767__auto__ portkey.aws/*http-client*)) ([input57622 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "DELETE", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/vaults/{vaultName}/multipart-uploads/{uploadId}"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/AbortMultipartUploadInput input57622)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"accountId" "accountId", "vaultName" "vaultName", "uploadId" "uploadId"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57621] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.glacier/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception}] (if (clojure.core/= 204 (:status response57621)) true (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57621 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57621)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57621})))))))))))

(clojure.core/defn add-tags-to-vault ([input__56767__auto__] (add-tags-to-vault input__56767__auto__ portkey.aws/*http-client*)) ([input57624 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "POST", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/vaults/{vaultName}/tags?operation=add"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/AddTagsToVaultInput input57624)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"accountId" "accountId", "vaultName" "vaultName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57623] (clojure.core/let [errors__56772__auto__ {"InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "ResourceNotFoundException" :portkey.aws.glacier/resource-not-found-exception, "LimitExceededException" :portkey.aws.glacier/limit-exceeded-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception}] (if (clojure.core/= 204 (:status response57623)) true (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57623 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57623)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57623})))))))))))

(clojure.core/defn initiate-vault-lock ([input__56767__auto__] (initiate-vault-lock input__56767__auto__ portkey.aws/*http-client*)) ([input57626 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "POST", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/vaults/{vaultName}/lock-policy"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/InitiateVaultLockInput input57626)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"accountId" "accountId", "vaultName" "vaultName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload "policy") (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57625] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.glacier/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception}] (if (clojure.core/= 201 (:status response57625)) (clojure.spec.alpha/unform :portkey.aws.glacier/initiate-vault-lock-output (:body response57625)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57625 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57625)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57625})))))))))))

(clojure.core/defn delete-vault ([input__56767__auto__] (delete-vault input__56767__auto__ portkey.aws/*http-client*)) ([input57628 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "DELETE", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/vaults/{vaultName}"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/DeleteVaultInput input57628)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"accountId" "accountId", "vaultName" "vaultName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57627] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.glacier/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception}] (if (clojure.core/= 204 (:status response57627)) true (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57627 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57627)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57627})))))))))))

(clojure.core/defn list-provisioned-capacity ([input__56767__auto__] (list-provisioned-capacity input__56767__auto__ portkey.aws/*http-client*)) ([input57630 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/provisioned-capacity"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/ListProvisionedCapacityInput input57630)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"accountId" "accountId"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57629] (clojure.core/let [errors__56772__auto__ {"InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception}] (if (clojure.core/= nil (:status response57629)) (clojure.spec.alpha/unform :portkey.aws.glacier/list-provisioned-capacity-output (:body response57629)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57629 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57629)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57629})))))))))))

(clojure.core/defn get-vault-lock ([input__56767__auto__] (get-vault-lock input__56767__auto__ portkey.aws/*http-client*)) ([input57632 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/vaults/{vaultName}/lock-policy"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/GetVaultLockInput input57632)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"accountId" "accountId", "vaultName" "vaultName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57631] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.glacier/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception}] (if (clojure.core/= nil (:status response57631)) (clojure.spec.alpha/unform :portkey.aws.glacier/get-vault-lock-output (:body response57631)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57631 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57631)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57631})))))))))))

(clojure.core/defn list-vaults ([input__56767__auto__] (list-vaults input__56767__auto__ portkey.aws/*http-client*)) ([input57634 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/vaults"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/ListVaultsInput input57634)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"accountId" "accountId"}) (portkey.awsgen/params-to-querystring {"marker" "marker", "limit" "limit"}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57633] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.glacier/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception}] (if (clojure.core/= nil (:status response57633)) (clojure.spec.alpha/unform :portkey.aws.glacier/list-vaults-output (:body response57633)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57633 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57633)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57633})))))))))))

(clojure.core/defn set-data-retrieval-policy ([input__56767__auto__] (set-data-retrieval-policy input__56767__auto__ portkey.aws/*http-client*)) ([input57636 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "PUT", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/policies/data-retrieval"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/SetDataRetrievalPolicyInput input57636)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"accountId" "accountId"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57635] (clojure.core/let [errors__56772__auto__ {"InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception}] (if (clojure.core/= 204 (:status response57635)) true (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57635 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57635)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57635})))))))))))

(clojure.core/defn get-job-output ([input__56767__auto__] (get-job-output input__56767__auto__ portkey.aws/*http-client*)) ([input57638 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/vaults/{vaultName}/jobs/{jobId}/output"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/GetJobOutputInput input57638)} (portkey.awsgen/params-to-header {"range" ["Range" nil]}) (portkey.awsgen/params-to-uri {"accountId" "accountId", "vaultName" "vaultName", "jobId" "jobId"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57637] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.glacier/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception}] (if (clojure.core/= nil (:status response57637)) (clojure.spec.alpha/unform :portkey.aws.glacier/get-job-output-output (:body response57637)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57637 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57637)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57637})))))))))))

(clojure.core/defn remove-tags-from-vault ([input__56767__auto__] (remove-tags-from-vault input__56767__auto__ portkey.aws/*http-client*)) ([input57640 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "POST", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/vaults/{vaultName}/tags?operation=remove"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/RemoveTagsFromVaultInput input57640)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"accountId" "accountId", "vaultName" "vaultName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57639] (clojure.core/let [errors__56772__auto__ {"InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "ResourceNotFoundException" :portkey.aws.glacier/resource-not-found-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception}] (if (clojure.core/= 204 (:status response57639)) true (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57639 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57639)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57639})))))))))))

(clojure.core/defn abort-vault-lock ([input__56767__auto__] (abort-vault-lock input__56767__auto__ portkey.aws/*http-client*)) ([input57642 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "DELETE", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/vaults/{vaultName}/lock-policy"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/AbortVaultLockInput input57642)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"accountId" "accountId", "vaultName" "vaultName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57641] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.glacier/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception}] (if (clojure.core/= 204 (:status response57641)) true (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57641 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57641)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57641})))))))))))

(clojure.core/defn list-parts ([input__56767__auto__] (list-parts input__56767__auto__ portkey.aws/*http-client*)) ([input57644 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/vaults/{vaultName}/multipart-uploads/{uploadId}"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/ListPartsInput input57644)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"accountId" "accountId", "vaultName" "vaultName", "uploadId" "uploadId"}) (portkey.awsgen/params-to-querystring {"marker" "marker", "limit" "limit"}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57643] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.glacier/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception}] (if (clojure.core/= nil (:status response57643)) (clojure.spec.alpha/unform :portkey.aws.glacier/list-parts-output (:body response57643)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57643 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57643)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57643})))))))))))

(clojure.core/defn set-vault-access-policy ([input__56767__auto__] (set-vault-access-policy input__56767__auto__ portkey.aws/*http-client*)) ([input57646 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "PUT", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/vaults/{vaultName}/access-policy"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/SetVaultAccessPolicyInput input57646)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"accountId" "accountId", "vaultName" "vaultName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload "policy") (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57645] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.glacier/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception}] (if (clojure.core/= 204 (:status response57645)) true (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57645 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57645)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57645})))))))))))

(clojure.core/defn create-vault ([input__56767__auto__] (create-vault input__56767__auto__ portkey.aws/*http-client*)) ([input57648 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "PUT", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/vaults/{vaultName}"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/CreateVaultInput input57648)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"accountId" "accountId", "vaultName" "vaultName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57647] (clojure.core/let [errors__56772__auto__ {"InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception, "LimitExceededException" :portkey.aws.glacier/limit-exceeded-exception}] (if (clojure.core/= 201 (:status response57647)) (clojure.spec.alpha/unform :portkey.aws.glacier/create-vault-output (:body response57647)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57647 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57647)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57647})))))))))))

(clojure.core/defn complete-vault-lock ([input__56767__auto__] (complete-vault-lock input__56767__auto__ portkey.aws/*http-client*)) ([input57650 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "POST", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/vaults/{vaultName}/lock-policy/{lockId}"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/CompleteVaultLockInput input57650)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"accountId" "accountId", "vaultName" "vaultName", "lockId" "lockId"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57649] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.glacier/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception}] (if (clojure.core/= 204 (:status response57649)) true (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57649 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57649)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57649})))))))))))

(clojure.core/defn upload-multipart-part ([input__56767__auto__] (upload-multipart-part input__56767__auto__ portkey.aws/*http-client*)) ([input57652 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "PUT", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/vaults/{vaultName}/multipart-uploads/{uploadId}"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/UploadMultipartPartInput input57652)} (portkey.awsgen/params-to-header {"checksum" ["x-amz-sha256-tree-hash" nil], "range" ["Content-Range" nil]}) (portkey.awsgen/params-to-uri {"accountId" "accountId", "vaultName" "vaultName", "uploadId" "uploadId"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload "body") (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57651] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.glacier/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "RequestTimeoutException" :portkey.aws.glacier/request-timeout-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception}] (if (clojure.core/= 204 (:status response57651)) (clojure.spec.alpha/unform :portkey.aws.glacier/upload-multipart-part-output (:body response57651)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57651 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57651)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57651})))))))))))

(clojure.core/defn upload-archive ([input__56767__auto__] (upload-archive input__56767__auto__ portkey.aws/*http-client*)) ([input57654 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "POST", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/vaults/{vaultName}/archives"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/UploadArchiveInput input57654)} (portkey.awsgen/params-to-header {"archiveDescription" ["x-amz-archive-description" nil], "checksum" ["x-amz-sha256-tree-hash" nil]}) (portkey.awsgen/params-to-uri {"vaultName" "vaultName", "accountId" "accountId"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload "body") (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57653] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.glacier/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "RequestTimeoutException" :portkey.aws.glacier/request-timeout-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception}] (if (clojure.core/= 201 (:status response57653)) (clojure.spec.alpha/unform :portkey.aws.glacier/archive-creation-output (:body response57653)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57653 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57653)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57653})))))))))))

(clojure.core/defn get-vault-access-policy ([input__56767__auto__] (get-vault-access-policy input__56767__auto__ portkey.aws/*http-client*)) ([input57656 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/vaults/{vaultName}/access-policy"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/GetVaultAccessPolicyInput input57656)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"accountId" "accountId", "vaultName" "vaultName"}) (portkey.awsgen/params-to-querystring {}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57655] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.glacier/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception}] (if (clojure.core/= nil (:status response57655)) (clojure.spec.alpha/unform :portkey.aws.glacier/get-vault-access-policy-output (:body response57655)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57655 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57655)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57655})))))))))))

(clojure.core/defn list-jobs ([input__56767__auto__] (list-jobs input__56767__auto__ portkey.aws/*http-client*)) ([input57658 http-client__56768__auto__] (clojure.core/let [endpoint__56769__auto__ (portkey.aws.glacier/endpoints portkey.aws/*region*) sig-opts__56770__auto__ (clojure.core/into (:credential-scope endpoint__56769__auto__) portkey.aws/*credentials*)] (clojure.core/-> {:method "GET", :headers {"content-type" "application/json"}, :url (clojure.core/str (:endpoint (endpoints portkey.aws/*region*)) "/{accountId}/vaults/{vaultName}/jobs"), :body (clojure.spec.alpha/unform :portkey.aws.glacier/ListJobsInput input57658)} (portkey.awsgen/params-to-header {}) (portkey.awsgen/params-to-uri {"accountId" "accountId", "vaultName" "vaultName"}) (portkey.awsgen/params-to-querystring {"limit" "limit", "marker" "marker", "statuscode" "statuscode", "completed" "completed"}) (portkey.awsgen/params-to-payload nil) (clojure.core/update :body (fn* [p1__56766__56771__auto__] (clojure.core/some-> p1__56766__56771__auto__ cheshire.core/generate-string))) (portkey.aws/sign-v4 sig-opts__56770__auto__) (http-client__56768__auto__ (clojure.core/fn [response57657] (clojure.core/let [errors__56772__auto__ {"ResourceNotFoundException" :portkey.aws.glacier/resource-not-found-exception, "InvalidParameterValueException" :portkey.aws.glacier/invalid-parameter-value-exception, "MissingParameterValueException" :portkey.aws.glacier/missing-parameter-value-exception, "ServiceUnavailableException" :portkey.aws.glacier/service-unavailable-exception}] (if (clojure.core/= nil (:status response57657)) (clojure.spec.alpha/unform :portkey.aws.glacier/list-jobs-output (:body response57657)) (clojure.core/if-some [[type__56773__auto__ spec__56774__auto__] (clojure.core/find errors__56772__auto__ (clojure.core/get-in response57657 [:headers "x-amzn-ErrorType"]))] (clojure.core/let [m__56775__auto__ (clojure.spec.alpha/unform spec__56774__auto__ (cheshire.core/parse-string (:body response57657)))] (throw (clojure.core/ex-info (clojure.core/str type__56773__auto__ ": " (:message m__56775__auto__)) m__56775__auto__))) (throw (clojure.core/ex-info "Unexpected response" {:response response57657})))))))))))
